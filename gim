#!/usr/bin/perl

use strict;
use warnings;
use utf8;
use open( ':std', ':encoding(UTF-8)' );

use Getopt::Long     qw( :config posix_default permute pass_through );
use Text::Wrap;

###################################################################
###################################################################
# Exit Codes
use constant E_OK            =>  0;
use constant E_SUB_MISSING   =>  1;  # No subcommand given
use constant E_SUB_UNKNOWN   =>  2;  # Subcommand unknown
use constant E_EXECUTE_FAIL  =>  3;  # Execution failure
use constant E_SIG_INTERRUPT =>  4;  # Interrupted by signal
use constant E_UNEXPECTED    =>  5;  # Unexpected backend error
use constant E_ARGUMENTS     =>  6;  # Wrong number of arguments
use constant E_NOTFILE       =>  7;  # Not a regular file
use constant E_NOTFILEORDIR  =>  8;  # Not a regular file or directory
use constant E_NOTTRACKED    =>  9;  # Not a file under version control
use constant E_INTERNAL      => 10;  # Internal error
use constant E_NOWORKINGCOPY => 11;  # Not a working copy
use constant E_SYNTAX        => 12;  # Command syntax error
use constant E_UNABLE        => 13;  # Subcommand precondition fail

###################################################################
# Repo Status
use constant S_OK            =>  0;
use constant S_DETACHED      =>  1;

###################################################################
# Colors

# Default is 'no color'
my $_COLOR   = 'never';
my $_RED     = '';
my $_GREEN   = '';
my $_BLUE    = '';
my $_YELLOW  = '';
my $_MAGENTA = '';
my $_CYAN    = '';
my $_RESET   = '';

if ( -t STDOUT )
{
    # If we are printing to terminal, *do* use colors.
    use Term::ANSIColor  qw( :constants );
    $_COLOR   = 'always';
    $_RED     = ::RED;
    $_GREEN   = ::GREEN;
    $_BLUE    = ::BLUE;
    $_YELLOW  = ::YELLOW;
    $_MAGENTA = ::MAGENTA;
    $_CYAN    = ::CYAN;
    $_RESET   = ::RESET;
}

# Color Scheme
my $_OK_COL       = $_GREEN;
my $_ERROR_COL    = $_RED;
my $_WARN_COL     = $_YELLOW;
my $_CURRENT_COL  = $_CYAN;
my $_UPSTREAM_COL = $_YELLOW;
my $_PUSH_COL     = $_BLUE;
my $_TIME_COL     = $_BLUE;
my $_NAME_COL     = $_CYAN;
my $_STASH_COL    = $_YELLOW;
my $_HASH_COL     = $_YELLOW;
my $_LOCAL_COL    = $_GREEN;
my $_REMOTE_COL   = $_RED;
my $_URL_COL      = $_MAGENTA;
my $_REF_COL      = $_CYAN;
my $_SYMREF_COL   = $_GREEN;
my $_LINE_COL     = $_MAGENTA;
my $_TAG_COL      = $_YELLOW;

###################################################################
# Globals
my %_catalog;    # Localized output texts -- [key] => text
my %_category =  # Command categories
(
    'info'    => { sortorder => 0, about => 'Obtaining information' },
    'local'   => { sortorder => 1, about => 'Act on your local repository' },
    'remote'  => { sortorder => 2, about => 'Act on a remote repository' }
);
my %_help;       # Help on [command] => category, about, usage, help
my %_topic;      # Help on [topic] => sortorder, about, help

###################################################################
# Reusable Regexes
{
    no warnings qw( qw );
    use constant RE_QUOTED_STRING => qw( '((?:\\\\?.)*?)' );
    use constant RE_COMMENT => qw( (\\s*(?:#.*)?) );
}

###################################################################
# General configuration
{
    use File::Basename qw( dirname );

    # Location of catalog files. For the time being uses gim's
    # own directory (so this works out of a repository).
    use constant CATALOG_DIR => dirname( __FILE__ ) . '/catalogs';
}

###################################################################
###################################################################
# 'dbg' provides call stack trace / log message functionality.
# With 'gim ... --debug', trace log is written to terminal. With
# 'gim ... --debug <filename>', trace log is written to file.
# Note that '--debug [<filename>]' needs to be at the end of the
# command line due to the way argument parsing works.
package dbg
{
    my $_dbg;
    our $_indent = 0;
    # NOT setting these with the other colors at the top of the
    # script, as debug coloring depends on whether *debug* goes to
    # terminal or file, not the general output.
    my $_dbg_color = ::MAGENTA;
    my $_dbg_clear = ::CLEAR;

    # Called from main's GetOptions, with an optional log filename
    # as second argument. (First argument of the function is always
    # 'debug'.) Initializes the debug file handle $_dbg.
    sub init( $;$ )
    {
        if ( length( $_[1] ) )
        {
            # Logging to file
            if ( ! open( $_dbg, '>', $_[1] ) )
            {
                $_dbg = util::pager();
                print( $_dbg util::text( 'Warning: Could not open debug output file ‘[_1]’.', $_[1] ) );
            }
            else
            {
                $_dbg_color = '';
                $_dbg_clear = '';
            }
        }
        else
        {
            $_dbg = util::pager();

            if ( ! -t STDOUT )
            {
                $_dbg_color = '';
                $_dbg_clear = '';
            }
        }
    }

    # Called upon subroutine entry. Prints stack trace entry and
    # increases indentation of subsequent entries.
    sub enter()
    {
        if ( defined( $_dbg ) )
        {
            package DB;
            print( $_dbg ( ' ' x $_indent ) . $_dbg_color . '>> ' . (caller(1))[3] . '(' );

            if ( (caller(1))[4] )
            {
                print( $_dbg ' ' . join( ', ', map { defined ? qq("$_") : '<undef>' } @DB::args ) . ' ' );
            }

            print( $_dbg ")$_dbg_clear\n" );
            $_indent += 3;
        }
    }

    # Print a log entry at current indentation.
    sub msg( $ )
    {
        if ( defined( $_dbg ) )
        {
            for ( split( "\n", $_[0] ) )
            {
                print( $_dbg ( ' ' x $_indent ) . $_dbg_color . $_ . $_dbg_clear . "\n" );
            }
        }
    }

    # Called before subroutine exit. Prints stack trace entry and
    # decreases indentation of subsequent entries.
    sub leave()
    {
        if ( defined( $_dbg ) )
        {
            $_indent -= 3;
            print( $_dbg ( ' ' x $_indent ) . $_dbg_color . '<< ' . (caller(1))[3] . $_dbg_clear . "\n" );
        }
    }

    # Close the debug file handle before exit.
    END
    {
        if ( defined( $_dbg ) && fileno( $_dbg ) )
        {
            dbg::msg( 'dbg::END' );
            close( $_dbg );
        }
    }
}

###################################################################
###################################################################
# 'git' covers various backend operations shared across Gim.
package git
{
    # Provides a log of the local repository, additional arguments
    # being optional. The fields (separated with ASCII FS, 0x1f):
    # - hash, complete
    # - timestamp, ISO
    # - timestamp, relative
    # - author name
    # - author email
    # - refs, colored
    # - commit subject
    #my ( $hash, $time_iso, $time_rel, $name, $mail, $refs, $msg ) = split( '\x{1f}' );
    sub log( ;$ )
    {
        return new executor( "git log --color=$_COLOR --pretty=format:'%H\x{1f}%ai\x{1f}%ar\x{1f}%aN\x{1f}%aE\x{1f}%C(auto)%d\x{1f}%s' @_", throw => 1 );
    }

    # Get a list of remotes
    sub remotes()
    {
        dbg::enter();
        my @remotes = split( "\n", util::execute( 'git remote', rc => -1, out => 1 ) );
        dbg::leave();
        return @remotes;
    }

    # Get a list of tags
    sub tags()
    {
        dbg::enter();
        my @tags = split( "\n", util::execute( 'git tag -l', rc => -1, out => 1 ) );
        return @tags;
        dbg::leave();
    }

    # Get a list of uncommitted changes in working directory
    sub uncommitted()
    {
        dbg::enter();
        my $output = util::execute( "git -c color.status=$_COLOR status --short",
                                    rc => -1, out => 1 );
        dbg::leave();
        return $output;
    }

    # Return the upstream and push branches for a given branch
    sub upstream( $ )
    {
        dbg::enter();
        my $command = 'git rev-parse --abbrev-ref --symbolic-full-name ' . $_[0];

        my ( $urc, $upstream ) = util::execute( $command . '@{upstream}', out => 1 );

        if ( $urc )
        {
            undef( $upstream );
        }

        my ( $prc, $push ) = util::execute( $command . '@{push}', out => 1 );

        if ( $prc )
        {
            undef( $push );
        }

        dbg::leave();
        return ( $upstream, $push );
    }

    # Get the URL of a given remote
    sub url( $ )
    {
        dbg::enter();
        my $url = util::execute( 'git config remote.' . $_[0] . '.url', rc => -1, out => 1 );
        dbg::leave();
        return $url;
    }
}

###################################################################
###################################################################
# 'l10n' loads a catalog file into the various data structures.
package l10n
{
    use I18N::LangTags qw( implicate_supers );
    use I18N::LangTags::Detect;

    # Load localizations from catalog file
    sub init()
    {
        dbg::enter();

        # Taking configured locale, and checking it and its supers
        # (de-de -> de) for existing catalog file.
        foreach ( implicate_supers( I18N::LangTags::Detect::detect() ) )
        {
            my $locale = $_;
            my $catalogfile = "${\::CATALOG_DIR}/$locale.catalog";
            dbg::msg( "Checking for ‘$catalogfile’" );

            if ( open( my $catalog, '<', $catalogfile ) )
            {
                # Reading file and passing to parse functions
                dbg::msg( "Reading ‘$locale.catalog’" );
                my $section = '';
                my @input = ();

                while ( <$catalog> )
                {
                    chomp;

                    if ( m/^\s*#/ )
                    {
                        # Skip comment lines
                        next;
                    }
                    elsif ( m/^\s*\[.*\]/ )
                    {
                        # Section header

                        # If the command is not 'gim help ...', we
                        # do not need to parse all the sections.
                        if ( ( ! defined( $ARGV[0] ) ) || ( $ARGV[0] ne 'help' ) )
                        {
                            last;
                        }

                        # Parse the last section
                        _parse( $section, \@input );

                        # Reset to new section
                        ( $section ) = m/^\s*\[(.*)\]/;
                        @input = ();
                    }
                    else
                    {
                        # Standard line
                        push( @input, $_ );
                    }
                }

                # We will likely have an unparsed section here
                if ( @input )
                {
                    _parse( $section, \@input );
                }

                close( $catalog );
                # No need to look any further
                last;
            }

            $locale = '';
        }

        dbg::leave();
    }

    # Parse array of inputs (second argument) into the %_catalog,
    # %_help, or %_topic hashes as appropriate
    sub _parse( $$ )
    {
        dbg::enter();

        if ( $_[0] eq '' )
        {
            _parse_catalog( $_[1] );
            dbg::leave();
            return;
        }

        my $item;

        # Cheking whether the [section] is a help item, a topic,
        # or neither (an error)
        if ( defined( $_help{ $_[0] } ) )
        {
            dbg::msg( "Parsing help for subcommand [$_[0]]" );
            $item = \%{ $_help{ $_[0] } };
        }
        elsif ( defined( $_topic{ $_[0] } ) )
        {
            dbg::msg( "Parsing help topic [$_[0]]" );
            $item = \%{ $_topic{ $_[0] } };
        }
        else
        {
            util::throw( ::E_INTERNAL, "Error: Unknown section [$_[0]] in catalog.\n" );
        }

        $item->{ about } = '';
        $item->{ help } = '';

        # Drop empty lines from the beginning
        while( @{$_[1]}[0] eq '' )
        {
            shift( @{$_[1]} );
        }

        # Drop empty lines from the end
        while( @{$_[1]}[-1] eq '' )
        {
            pop( @{$_[1]} );
        }

        foreach ( @{$_[1]} )
        {
            chomp;

            if ( $item->{ about } eq '' )
            {
                # First line -- 'about' summary
                $item->{ about } = $_;
            }
            elsif ( $item->{ help } eq '' )
            {
                # This skips empty lines between summary and body
                $item->{ help } = $_;
            }
            else
            {
                # Empty lines mark a paragraph
                if ( $_ eq '' )
                {
                    $item->{ help } .= "\n\n";
                }
                else
                {
                    $item->{ help } .= ' ' . $_;
                }
            }
        }

        chomp( $item->{ help } );
        dbg::leave();
    }

    # Parse array of inputs of main catalog into the %_catalog hash
    sub _parse_catalog( $ )
    {
        dbg::enter();

        foreach( @{$_[0]} )
        {
            chomp;

            if ( m/^\s*$/ )
            {
                # Skip empty lines
                next;
            }

            # 'Key phrase' => 'Localized phrase' # Comment
            my ( $key, $value, $rest ) = m/^\s*${\::RE_QUOTED_STRING}\s*=>\s*${\::RE_QUOTED_STRING}${\::RE_COMMENT}$/;

            if ( defined( $rest ) )
            {
                # Success
                $_catalog{ $key } = $value;
            }
            else
            {
                util::throw( ::E_INTERNAL, "Error: Malformed line in catalog.\n  => $_\n" );
            }
        }

        dbg::leave();
    }
}

###################################################################
###################################################################
# 'util' covers any utility subroutines.
package util
{
    # Check that the number of arguments (remaining @ARGV) is no
    # less than the first and no more than the second argument.
    # -1 means 'no check'.
    sub check_argv( $$ )
    {
        dbg::enter();

        if ( @ARGV < $_[0] )
        {
            util::throw( ::E_ARGUMENTS, util::text( 'Error: Too few arguments.' ) .
                                        util::text( 'Try ‘[_1]’.', 'gim help ' . caller(0) ) );
        }

        if ( ( $_[1] > -1 ) && ( @ARGV > $_[1] ) )
        {
            util::throw( ::E_ARGUMENTS, util::text( 'Error: Too many arguments.' ) .
                                        util::text( 'Try ‘[_1]’.', 'gim help ' . caller(0) ) );
        }

        dbg::leave();
    }

    # Check if the list of arguments violates a predicate given
    # as first parameter. Returns if all arguments check out,
    # throws otherwise. Generates warnings for symbolic links,
    # which are not portable across platforms.
    # Predicates:
    # ::E_NOTFILE      -- if item is regular file
    # ::E_NOTFILEORDIR -- if item is regular file or directory
    # ::E_NOTTRACKED   -- if item is not under version control
    sub check_filespecs( $@ )
    {
        dbg::enter();
        my $pager = util::pager();
        my $func = shift( @_ );

        foreach ( @_ )
        {
            my $filespec = $_;
            dbg::msg( "checking ‘$filespec’" );

            use feature qw( switch );
            no warnings qw( experimental::smartmatch );

            given ( $func )
            {
                when ( ::E_NOTFILE )
                {
                    if ( ! -f $filespec )
                    {
                        util::throw( ::E_NOTFILE, util::text( 'Error: ‘[_1]’ is not a regular file.', $filespec ) );
                    }
                }
                when ( ::E_NOTFILEORDIR )
                {
                    if ( ! -f $filespec && ! -d $filespec )
                    {
                        util::throw( ::E_NOTFILEORDIR, util::text( 'Error: ‘[_1]’ is neither regular file nor directory.', $filespec ) );
                    }
                }
                when ( ::E_NOTTRACKED )
                {
                    if ( util::execute( "git ls-files --error-unmatch $filespec" ) )
                    {
                        util::throw( ::E_NOTTRACKED, util::text( 'Error: ‘[_1]’ is not under version control.', $filespec ) );
                    }
                }
                default
                {
                    util::throw( ::E_INTERNAL, 'Error: Unknown predicate in check_filespecs().' )
                }
            }

            if ( -l $filespec )
            {
                print( $pager util::text( 'Warning: ‘[_1]’ is a symbolic link, which is not portable.', $filespec ) );
            }
        }

        dbg::leave();
    }

    # Check return code from external calls
    sub check_rc( $$ )
    {
        dbg::enter();
        my ( $rc, $command ) = @_;

        # Mapping of signal numbers to signal names for error messages
        use Config '%Config';
        my @sig_names;
        @sig_names[ split( ' ', $Config{ sig_num } ) ] = split( ' ', $Config{ sig_name } );

        if ( $rc != 0 )
        {
            if ( $rc == -1 )
            {
                util::throw( ::E_EXECUTE_FAIL, util::text( 'Error: Failed to execute ‘[_1]’.', 'sh' ) );
            }
            elsif ( $rc & 127 )
            {
                $rc &= 127;
                util::throw( ::E_SIG_INTERRUPT, util::text( 'Error: ‘[_1]’ interrupted by signal [_2] ‘[_3]’.', $command, $rc, $sig_names[ $rc ] ) );
            }
            else
            {
                $rc = $rc >> 8;

                if ( $rc > 128 )
                {
                    $rc -= 128;
                    util::throw( ::E_SIG_INTERRUPT, util::text( 'Error: ‘[_1]’ interrupted by signal [_2] ‘[_3]’.', $command, $rc, $sig_names[ $rc ] ) );
                }
                if ( $rc == 127 )
                {
                    util::throw( ::E_EXECUTE_FAIL, util::text( 'Error: Failed to execute ‘[_1]’.', $command ) .
                                                   util::text( 'Command not found.' )
                    );
                }
                elsif ( $rc == 126 )
                {
                    util::throw( ::E_EXECUTE_FAIL, util::text( 'Error: Command ‘[_1]’ not executable.', $command ) );
                }
            }
        }

        dbg::leave();
        return $rc;
    }

    # Check that the list of arguments exists as tags in the repo.
    # Returns if all arguments check out, throws otherwise.
    sub check_tags(@)
    {
        dbg::enter();
        my @tags = git::tags();

        foreach ( @_ )
        {
            my $tag = $_;

            if ( ! grep( /^$tag$/, @tags ) )
            {
                util::throw( ::E_SYNTAX, util::text( 'Error: Unknown tag: ‘[_1]’.', $_ ) );
            }
        }

        dbg::leave();
    }

    # Request confirmation from user.
    sub confirmation()
    {
        dbg::enter();
        print( "\n" . util::text( "Enter yes/[N]o: " ) );
        my $positive = util::text( "yes" );
        chomp( $positive );
        my $answer = <STDIN>;
        chomp( $answer );

        if ( ! defined( $answer ) || length( $answer ) == 0 )
        {
            print( "No\n" );
        }

        dbg::msg( "Answer: ‘$answer’" );
        dbg::msg( "Positive: ‘$positive’" );
        dbg::leave();
        return ( defined( $answer ) && ( $answer eq $positive ) );
    }

    # Execute external command.
    # rc => -1: Throw if command returns non-zero
    # rc =>  0: Throw on failure to execute
    # rc =>  1: Return the command's return code (default)
    # out => -1: Output pass through
    # out =>  0: Ignore the command's output (default)
    # out =>  1: Return the command's output
    sub execute( $;@ )
    {
        dbg::enter();
        my $command = shift @_;
        my %options = ( rc => 1, out => 0, @_ );
        my $output = '';

        if ( $options{ out } >= 0 )
        {
            $output = `$command 2>&1`;
            chomp( $output );
            dbg::msg( "$output" );
        }
        else
        {
            system( "$command" );
        }

        my $rc = check_rc( $?, $command );

        if ( ( $options{ rc } == -1 ) && ( $rc != 0 ) )
        {
            util::throw( ::E_UNEXPECTED, util::text( 'Error: Failed to execute ‘[_1]’.', caller(0) ) .
                                         util::text( '‘[_1]’ returned ‘[_2]’:', $command, $rc ) .
                                         $output . "\n" );
        }

        dbg::leave();

        if ( ( $options{ rc } == 1 ) && ( $options{ out } == 1 ) )
        {
            return ( $rc, $output );
        }
        elsif ( $options{ out } == 1 )
        {
            return $output;
        }
        else
        {
            return $rc;
        }
    }

    my $_pager;

    # Acquire a handle to the output pager process. There will be
    # only one pager process, even if this subroutine is called
    # multiple times.
    # If output is not to a terminal (e.g. redirected into a file)
    # then the pager will be 'cat' (i.e., pass-through).
    # If the environment variable GIM_PAGER is set, that will be
    # the pager used.
    # The default pager is 'less'. If the LESS environment variable
    # is set, it will be used; else the '-FeRSX' options will be set.
    # Note that Git's core.pager is NOT honored.
    sub pager()
    {
        dbg::enter();

        if ( ! defined( $_pager ) )
        {
            my $cmd;
            $Text::Wrap::columns = ( `tput cols` || 76 ) - 2;

            if ( -t STDOUT )
            {
                if ( exists( $ENV{ GIM_PAGER } ) )
                {
                    $cmd = $ENV{ GIM_PAGER };
                }
                else
                {
                    if ( exists( $ENV{ LESS } ) )
                    {
                        $cmd = 'less';
                    }
                    else
                    {
                        $cmd = 'less -FeRSX';
                    }
                }
            }
            else
            {
                $cmd = 'cat';
            }

            if ( ! open( $_pager, "| $cmd" ) )
            {
                util::throw( ::E_EXECUTE_FAIL, util::text( 'Error: Failed to execute ‘[_1]’.', $cmd ) );
            }
        }

        dbg::leave();
        return $_pager;
    }

    # This function quotes its arguments
    sub qtd( @ )
    {
        dbg::enter();
        my @new;

        foreach ( @_ )
        {
            my $need_quotes = m/[ '&\*<>\[\]|\(\);\a\f\n\r\t\v]/;

            s/([\\`"\$])/\\$1/g;

            if ( $need_quotes )
            {
                $_ = '"' . $_ . '"';
            }

            push( @new, $_ );
        }

        dbg::leave();
        return @new;
    }

    sub separator()
    {
        return ( '-' x $Text::Wrap::columns ) . "\n";
    }

    # Pull subcommand from @ARGV.
    # When called from the top level, checks existence of worker
    # class by that name, and returns an instance of that class.
    # When called from a worker class, checks existence of a run_*
    # subroutine of that name, and returns that subroutine name.
    sub subcommand()
    {
        dbg::enter();
        my $subcommand = shift( @ARGV ) // '';
        my $caller = caller(0);
        my $help_hint;
        my $command;
        my $package;
        my $rc;

        if ( $caller eq 'gim' )
        {
            $help_hint = '';
            $command = $caller;
            $package = $subcommand;
        }
        else
        {
            $help_hint = ' ' . $caller;
            $command = 'gim ' . $caller;
            $package = $caller . '::' . $subcommand;
        }

        if ( $subcommand eq '' )
        {
            util::throw( ::E_SUB_MISSING, util::text( 'Error: No subcommand given to ‘[_1]’.', $command ) .
                                          util::text( 'Try ‘[_1]’.', 'gim help' . $help_hint ) );
        }

        if ( $package->isa( 'worker' ) && $package ne 'worker' )
        {
            $rc = $package->new();
        }
        else
        {
            util::throw( ::E_SUB_UNKNOWN, util::text( 'Error: Unknown subcommand ‘[_1]’.', $subcommand ) .
                                          util::text( 'Try ‘[_1]’.', 'gim help' . $help_hint ) );
        }

        dbg::leave();
        return $rc;
    }

    # Given a basic message and a list of arguments, this function:
    # 1) looks up the basic message in the catalog, replacing it
    #    with a localized version if available;
    # 2) inserts arguments in place of placeholders '[_1]', '[_2]'
    #    etc. in the (localized) basic message;
    # 3) If input message started with 'Error:' or 'Warning:', will
    #    color output message up to the first ':' with _ERROR_COL /
    #    _WARN_COL.
    sub text( $;@ )
    {
        dbg::enter();
        my $text = $_catalog{ $_[0] } || $_[0];

        # Replace '[_n]' with argument #n.
        for ( my $i = 1; $i < @_; ++$i )
        {
            $text =~ s/\[_$i\]/$_[ $i ]/;
        }

        if ( $_[0] =~ m/^Error:/ )
        {
            $text =~ s/^/$_ERROR_COL/;
            $text =~ s/:/:$_RESET/;
        }

        if ( $_[0] =~ m/^Warning:/ )
        {
            $text =~ s/^/$_WARN_COL/;
            $text =~ s/:/:$_RESET/;
        }

        dbg::leave();
        return $text . "\n";
    }

    # Throw Gim two-element exception: $0 as the error code, $1 as
    # the exception message.
    sub throw( @ )
    {
        my $msg = ( '<' x $dbg::_indent );
        $dbg::_indent = 0;
        $! = $_[0];
        die( $_[1] );
    }

    END
    {
        dbg::msg( 'util::END' );

        if ( defined( $_pager ) )
        {
            close( $_pager );
        }
    }
}

###################################################################
###################################################################
# Similar to util::execute(), which provides combined stdout and
# stderr of a command in scalar return values, this class gives
# access to stdout of a command line by line.
#
# $self->{ out } is a stream handle on stdout.
# $self->{ err } is a stream handle on stderr.
# $self->{ errors } will receive a dump of $self->{ err } when
# $self->close() is called.
package executor
{
    # Requires the command to be executed as parameter.
    sub new( $ )
    {
        dbg::enter();
        use IPC::Open3;
        my $class = shift( @_ );
        my $self = {};
        $self->{ command } = shift( @_ );
        bless( $self, $class );

        use Symbol 'gensym';
        $self->{ err } = gensym;
        eval { $self->{ pid } = open3( $self->{ in }, $self->{ out }, $self->{ err }, $self->{ command } ); };

        if ( $@ )
        {
            dbg::msg( 'Exception thrown by open3()' );
            dbg::msg( $@ );
            $self->{ pid } = 0;
            util::throw( ::E_EXECUTE_FAIL, util::text( 'Error: Failed to execute ‘[_1]’.', $self->{ command } ) . $! . "\n" );
        }

        util::pager()->autoflush( 1 );
        $self->{ 'linecount' } = 0;

        dbg::leave();
        return $self;
    }

    # Writes a line of output to $_.
    sub readline()
    {
        dbg::enter();
        my $self = shift( @_ );
        my $fh = $self->{ out };

        if ( defined( $_ = <$fh> ) )
        {
            ++$self->{ 'linecount' };
        }

        dbg::leave();
        return $_;
    }

    # Closes the stream, writing stderr to $self->{ errors }.
    # This is optional, as the destructor will do it anyway.
    sub close()
    {
        dbg::enter();
        my $self = shift( @_ );

        if ( $self->{ pid } ne 0 )
        {
            my $fh = $self->{ err };
            $self->{ errors } = do { local $/; <$fh> };

            if ( length( $self->{ errors } ) > 0 )
            {
                dbg::msg( "Output on stderr: $self->{ errors }" );
            }

            dbg::msg( "waiting for $self->{ pid }" );
            waitpid( $self->{ pid }, 0 );
            $self->{ pid } = 0;
            $self->{ rc } = util::check_rc( $?, $self->{ command } );
        }

        dbg::leave();
    }

    sub DESTROY
    {
        dbg::enter();
        my $self = shift;
        $self->close();
        dbg::leave();
    }
}

###################################################################
###################################################################
# Base class for all subcommands.
package worker
{
    sub new()
    {
        dbg::enter();
        my $class = shift( @_ );
        my $self = {};
        bless( $self, $class );
        dbg::leave();
        return $self;
    }

    sub init()
    {
        dbg::enter();
        my $self = shift( @_ );
        $self->{ 'repo_status' } = ::S_OK;

        # Git directory
        my $command = 'git rev-parse --git-dir';
        ( my $rc, $self->{ 'git_dir' } ) = util::execute( $command, out => 1 );

        if ( $rc != 0 )
        {
            if ( $rc == 128 )
            {
                util::throw( ::E_NOWORKINGCOPY, util::text( 'Error: ‘[_1]’ requires a working copy.', 'gim ' . caller(0) ) );
            }
            else
            {
                util::throw( ::E_UNEXPECTED, util::text( 'Error: Failed to execute ‘[_1]’.', 'worker::init' ) .
                                             util::text( '‘[_1]’ returned ‘[_2]’:', $command, $rc ) .
                                             $self->{ 'git_dir' } . "\n"
                );
            }
        }

        dbg::msg( 'git_dir is \'' . $self->{ 'git_dir' } . '\'' );

        # Current branch
        ( $rc, $self->{ 'current_branch' } ) = util::execute( 'git symbolic-ref --short HEAD',
                                                              out => 1 );

        if ( $rc == 128 )
        {
            $self->{ 'current_branch' } = util::execute( 'git status --porcelain=2 --branch | head -n 1', rc => -1, out => 1 );
            $self->{ 'current_branch' } =~ s/# branch\.oid ([0-9a-f]{7}).*/<unnamed:$1>/;
            $self->{ 'repo_status' } = ::S_DETACHED;
        }

        dbg::msg( 'current branch is \'' . $self->{ 'current_branch' } . '\'' );

        # Latest pushed
        ( $rc, $self->{ 'latest_pushed' } ) = util::execute( 'git rev-parse @{push}',
                                                             out => 1 );

        if ( $rc )
        {
            undef( $self->{ 'latest_pushed' } );
        }

        dbg::leave();
    }
}

package fileworker
{
    our @ISA = 'worker';
}

package branchworker
{
    our @ISA = 'worker';
}

###################################################################
# 'add' files to version control
package add
{
    our @ISA = 'fileworker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        $self->init();
        util::check_argv( 1, -1 );
        util::check_filespecs( ::E_NOTFILEORDIR, @ARGV );
        my @args = util::qtd( @ARGV );
        # '--intent-to-add' in combination with 'commit --all'
        # effectively removes staging from the workflow.
        # '--no-all' avoids filesystem deletions resulting in
        # removal from version control, which was considered
        # surprising (a.k.a. 'bad').
        util::execute( "git add --intent-to-add --no-all -- @args", rc => -1 );
        dbg::leave();
        return ::E_OK;
    }

$_help{ 'add' } =
{
    category => 'local',
    about => 'Add files to version control',
    usage => q{gim add <filespec> [<filespec> ...]
},
    help => q{Add files to version control.

Actually this just earmarks the files, which will be added to your
local repository with the next commit.

Directories specified as arguments will be added including their
contents, recursively.
}};

}

###################################################################
# 'blame' identifies who made which changes to a source file
package blame
{
    our @ISA = 'fileworker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        $self->init();
        my $date = '';
        my $regex = '([^ ]*) \((.*?) (\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2} .\d{4})\s*(\d*)\) (.*)';
        Getopt::Long::GetOptions(
            'relative|r' => sub {
                $date = '--date=relative';
                $regex = '([^ ]*) \((.*?) (\d+ [a-z]* [a-z]*)\s*(\d*)\) (.*)';
            }
        );
        util::check_argv( 1, 1 );
        my @args = util::qtd( @ARGV );
        util::check_filespecs( ::E_NOTTRACKED, @args );
        my $pager = util::pager();

        my $blame = new executor( "git blame $date @args" );
        my $last = '';
        my $linecol = $_LINE_COL;

        while ( $blame->readline() )
        {
            $_ =~ /$regex/;

            if ( $1 ne $last )
            {
                $linecol = ( $linecol eq $_LINE_COL ) ? $_RESET : $_LINE_COL;
            }

            printf( $pager "%s%s%s %s%-15.15s%s %s%-15s%s %s%5d)%s  %s\n",
                    $_HASH_COL, $1, $_RESET,
                    $_NAME_COL, $2, $_RESET,
                    $_TIME_COL, $3, $_RESET,
                    $linecol, $4, $_RESET,
                    $5
                );

            $last = $1;
        }

        $blame->close();
        dbg::leave();
        return ::E_OK;
    }

$_help{ 'blame' } =
{
    category => 'info',
    about => 'Show who modified which line when',
    usage => q{gim blame <file>
},
    help => q{Show who modified which line when.
}};

}

###################################################################
# 'chmod' modifies the executable flag of a file
package chmod
{
    our @ISA = 'fileworker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        $self->init();
        util::check_argv( 2, -1 );
        my $mode = shift( @ARGV );
        my @args = util::qtd( @ARGV );
        util::check_filespecs( ::E_NOTTRACKED, @args );
        util::execute( "chmod $mode @args", rc => -1, out => -1 );
        util::execute( "git update-index --chmod=$mode @args", rc => -1, out => -1 );
        dbg::leave();
        return ::E_OK;
    }

$_help{ 'chmod' } =
{
    category => 'local',
    about => 'Modify executable flag',
    usage => q{gim chmod [+x|-x] <filespec> [<filespec> ...]
},
    help => q{Modify the executable flag of file(s).

Set / unset the executable flag of one or more files.
}};

}

###################################################################
# 'clone' a repository
package clone
{
    our @ISA = 'fileworker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        util::check_argv( 1, 2 );
        my @args = util::qtd( @ARGV );
        util::execute( "git clone --quiet --no-local -- @args", rc => -1, output => -1 );
        dbg::leave();
        return ::E_OK;
    }

$_help{ 'clone' } =
{
    category => 'local',
    about => 'Clone a repository',
    usage => q{gim clone <upstream> [<local>]
},
    help => q{Clone a repository.

Create a new local repository and working copy as clone of an
upstream repository.
}};

}

###################################################################
# 'commit' changes in the working directory to local repository.
package commit
{
    our @ISA = 'fileworker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        $self->init();
        my $amend;
        my $file;
        my $msg;
        Getopt::Long::GetOptions(
            'amend'       => \$amend,
            'file|F=s'    => \$file,
            'message|m=s' => \$msg
        );

        if ( defined( $file ) && defined( $msg ) )
        {
            util::throw( ::E_SYNTAX, util::text( 'Error: Conflicting options ‘[_1]’ and ‘[_2]’.', '--file', '--message' ) );
        }

        my $command = 'git commit --quiet';

        if ( defined( $amend ) )
        {
            $command .= ' --amend';
        }

        if ( defined( $file ) )
        {
            util::check_filespecs( ::E_NOTFILE, $file );
            ( $file ) = util::qtd( $file );
            $command .= " --file $file";
        }

        if ( defined( $msg ) )
        {
            ( $msg ) = util::qtd( $msg );
            $command .= " --message $msg";
        }

        if ( @ARGV )
        {
            if ( $ARGV[0] eq '--' )
            {
                shift @ARGV;
            }

            util::check_filespecs( ::E_NOTFILEORDIR, @ARGV );
            my @args = util::qtd( @ARGV );
            $command .= " -- @args";
        }
        else
        {
            $command .= ' --all';
        }

        util::execute( "$command", rc => -1, out => -1 );
        dbg::leave();
        return ::E_OK;
    }

$_help{ 'commit' } =
{
    category => 'local',
    about => 'Commit changes to local repository',
    usage => q{gim commit [--amend] [<filespec> ...]
    gim commit [--amend] [--message | -m <msg>] [<filespec> ...]
    gim commit [--amend] [--file | -F <filename>] [<filespec> ...]
},
    help => q{Commit changes to the local repository.

The first variant opens an editor for you to enter the commit
message.

The second variant uses the passed string as the commit message.

The third variant uses the contents of the specified file as the
commit message.

If the ‘--amend’ option is specified, the last commit (which must
not have been published yet) will be amended instead of creating a
new commit.
}};

}

###################################################################
# 'devel' covers everything for internal Gim development. None of
# this should ever be needed by the casual Gim user.
package devel
{
    our @ISA = 'worker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        util::check_argv( 1, 1 );
        my $subcommand = util::subcommand();
        $subcommand->run();
        dbg::leave();
        return ::E_OK;
    }

    # 'devel catalog' generates a catalog, containing all texts
    # that need to be localized.
    package devel::catalog
    {
        our @ISA = 'devel';

        sub run()
        {
            dbg::enter();
            my $catalog_file = 'i-default.catalog';

            if ( -e $catalog_file )
            {
                die "Refusing to overwrite existing ‘$catalog_file’.";
            }

            print( "Writing catalog template to ‘$catalog_file’.\n" );

            # Reading util::text strings from script
            # Stored in a map so duplicate entries get squashed into one
            open( my $script, '<', __FILE__ ) || die 'Failed to open script for inspection.';
            my %out;
            my %warn;
            my %err;

            while ( <$script> )
            {
                my ( $key ) = m/util::text\( *${\::RE_QUOTED_STRING}/;

                if ( defined( $key ) )
                {
                    if ( $key =~ m/^Error: / )
                    {
                        $err{ $key } = 1;
                    }
                    elsif ( $key =~ m/^Warning: / )
                    {
                        $warn{ $key } = 1;
                    }
                    else
                    {
                        $out{ $key } = 1;
                    }
                }
            }

            close( $script );

            open( my $catalog, '>', $catalog_file );

            # Output messages
            print( $catalog "# Localize by translating the right-hand side strings.\n" .
                            "# Do not edit the left-hand side strings, they are used for lookup.\n" .
                            "\n# General output\n\n" );

            foreach ( sort keys %out )
            {
                printf( $catalog "%-45s => %s\n", "'$_'", "'$_'" );
            }

            # Warning messages
            print( $catalog "\n# Warning messages\n\n" );

            foreach ( sort keys %warn )
            {
                printf( $catalog "%-65s => %s\n", "'$_'", "'$_'" );
            }

            # Error messages
            print( $catalog "\n# Error messages\n\n" );

            foreach ( sort keys %err )
            {
                printf( $catalog "%-65s => %s\n", "'$_'", "'$_'" );
            }

            # Help categories
            print( $catalog "\n# Categories\n\n" );

            foreach( sort { $_category{ $a }{ sortorder } <=> $_category{ $b }{ sortorder } } keys %_category )
            {
                my $about = "'$_category{ $_ }{ about }'";
                printf( $catalog "%-35s => %-35s # %s\n", $about, $about, $_ );
            }

            # Help texts for commands
            print( $catalog "\n" . ( '#' x 68 ) . "\n# Subcommands\n\n" .
                            "# Localize by translating the text.\n" .
                            "# The first line is the 'about' line written by 'gim help'.\n" .
                            "# The remaining text is formatted by Text::Wrap, so use empty\n" .
                            "# lines to mark paragraphs and do not bother with line lengths.\n" .
                            "# Do not edit the command name in square brackets, it is used for\n" .
                            "# lookup.\n"
            );

            foreach ( sort keys %_help )
            {
                printf( $catalog "\n[%s]\n\n%s\n\n%s", $_, $_help{ $_ }{ about }, $_help{ $_ }{ help } );

                if ( ! $_category{ $_help{ $_ }{ category } } )
                {
                    print( STDERR "‘$_’: Unknown category ‘$_help{ $_ }{ category }’" );
                }
            }

            # Help texts for topics
            print( $catalog "\n" . ( '#' x 68 ) . "\n# Topics\n\n" .
                            "# Same as for Subcommands above. First line is 'about', the\n" .
                            "# remaining text will be formatted by Text::Wrap. Leave the\n" .
                            "# topic name in square brackets alone.\n"
            );

            foreach ( sort { $_topic{ $a }{ sortorder } <=> $_topic{ $b }{ sortorder } } keys %_topic )
            {
                printf( $catalog "\n[%s]\n\n%s\n\n%s", $_, $_topic{ $_ }{ about }, $_topic{ $_ }{ help } );
            }

            close( $script );
            dbg::leave();
        }
    }

    # 'devel completion' generates bash code for command line
    # completion.
    package devel::completion
    {
        our @ISA = 'devel';

        sub run()
        {
            dbg::enter();
            use mro;
            my @worker = sort grep( !/::|worker/, @{ mro::get_isarev( 'worker' ) } );
            my $fileworker = join( "|", sort grep( !/::/, @{ mro::get_isarev( 'fileworker' ) } ) );
            my $branchworker = join( "|", sort grep( !/::/, @{ mro::get_isarev( 'branchworker' ) } ) );
            my @devel = sort map( s/.*:://r, @{ mro::get_isarev( 'devel' ) } );
            my @stash = sort map( s/.*:://r, @{ mro::get_isarev( 'stash' ) } );
            my @tag = sort map( s/.*:://r, @{ mro::get_isarev( 'tag' ) } );
            my @topics = sort keys %_topic;
            ( my $completion = qq{#!/usr/bin/env bash

            _gim_completions()
            {
                compopt +o default
                local cur prev
                cur="\${COMP_WORDS[COMP_CWORD]}"
                prev="\${COMP_WORDS[COMP_CWORD-1]}"
                pprev="\${COMP_WORDS[COMP_CWORD-2]}"

                case \${#COMP_WORDS[@]} in
                    2)
                        COMPREPLY+=(\$(compgen -W "@worker" -- "\$cur"))
                        ;;
                    3)
                        case \$prev in
                            help)
                                COMPREPLY+=(\$(compgen -W "@worker topic" -- "\$cur"))
                                ;;
                            devel)
                                COMPREPLY+=(\$(compgen -W "@devel" -- "\$cur"))
                                ;;
                            stash)
                                COMPREPLY+=(\$(compgen -W "@stash" -- "\$cur"))
                                ;;
                            tag)
                                COMPREPLY+=(\$(compgen -W "@tag" -- "\$cur"))
                                ;;
                            $fileworker)
                                compopt -o default
                                COMPREPLY=()
                                ;;
                            $branchworker)
                                COMPREPLY+=(\$(compgen -W "\$(git for-each-ref --format="%(refname:strip=2)" refs/heads/*)" -- "\$cur"))
                                ;;
                        esac
                        ;;
                    4)
                        case \$pprev in
                            help)
                                case \$prev in
                                    topic)
                                        COMPREPLY+=(\$(compgen -W "@topics" -- "\$cur"))
                                        ;;
                                    *)
                                        ;;
                                esac
                                ;;
                            tag)
                                case \$prev in
                                    delete|list)
                                        COMPREPLY+=(\$(compgen -W "\$(git tag -l | tr '\\n' ' ')" -- "\$cur"))
                                        ;;
                                    *)
                                        ;;
                                esac
                                ;;
                            *)
                                compopt -o default
                                COMPREPLY=()
                                ;;
                        esac
                        ;;
                    *)
                        compopt -o default
                        COMPREPLY=()
                        ;;
                esac
            }

            complete -F _gim_completions gim
})
            =~ s/^ {8}//mg;
            open( my $fh, '>', 'gim-completion.bash' ) || die( "Error: Could not open 'gim-completion.bash' for writing.\n" . $! );
            print( $fh $completion );
            close( $fh );
            chmod( 0755, 'gim-completion.bash' );
            dbg::leave();
        }
    }

    # 'devel qtd' runs a couple of tests on util::qtd.
    package devel::qtd
    {
        our @ISA = 'devel';

        sub run()
        {
            dbg::enter();
            my $self = shift( @_ );

            my %tests = ( 'foo bar' => '"foo bar"',
                          'foo$bar' => "foo\$bar",
                          'foo&bar' => '"foo&bar"',   # FIXME
                          'foo*bar' => '"foo*bar"',
                          'foo<bar' => '"foo<bar"',
                          'foo`bar' => '"foo\`bar"',  #FIXME
                          'foo"bar' => '"foo\"bar"',  #FIXME
                          'foo[bar' => '"foo[bar"',
                          'foo|bar' => '"foo|bar"',
                          'foo(bar' => '"foo(bar"',
                          'foo;bar' => '"foo;bar"',
                          'foo\bar' => '"foo\\bar"',  # FIXME
                          'foo	bar' => '"foo	bar"',
                        );

            my @quoted = util::qtd( keys %tests );

            while ( my ( $expected, $input ) = sort each %tests )
            {
                my $observed = shift( @quoted );

                printf( "%10s -> %10s ... ", $input, $expected );

                if ( $observed eq $expected )
                {
                    printf( "%s%s%s\n", $_OK_COL, "OK", $_RESET );
                }
                else
                {
                    printf( "%s%s%s (got: %s)\n", $_ERROR_COL, "ERR", $_RESET, $observed );
                }
            }

            dbg::leave();
        }
    }

    # 'setup' sets up a number of repositories for feature testing
    package devel::setup
    {
        our @ISA = 'devel';

        sub run()
        {
            dbg::enter();
            use Cwd;
            use File::Path       qw( make_path remove_tree );
            remove_tree( 'setup' );

            sub subdir($)
            {
                dbg::enter();
                my $subdir = 'setup/' . shift( @_ );
                make_path( $subdir );
                chdir( $subdir );
                dbg::leave()
            }

            # Triangle workflow -- pull from one, push to another
            subdir( 'triangle' );
            util::execute( 'git init --bare upstream', rc => -1 );
            util::execute( 'git clone upstream workdir', rc => -1 );
            # creating commit and pushing to upstream
            chdir( 'workdir' );
            open( my $fh, '>>foo' );
            close( $fh );
            util::execute( 'git add foo', rc => -1 );
            util::execute( 'git commit -m "foo" foo', rc => -1 );
            util::execute( 'git push', rc => -1 );
            chdir( '..' );
            # setting up push repo
            util::execute( 'git init --bare push', rc => -1 );
            chdir( 'push' );
            my $pushrepo = getcwd();
            util::execute( 'git remote add push ' . $pushrepo, rc => -1 );
            my $current = util::execute( 'git symbolic-ref --short HEAD', rc => -1, out => 1 );
            util::execute( 'git config branch.' . $current . '.pushremote push', rc => -1 );
            util::execute( 'git config push.default current', rc => -1 );
            chdir( '..' );
            # creating commit and pushing to push
            chdir( 'workdir' );
            open( $fh, '>>bar' );
            close( $fh );
            util::execute( 'git add bar', rc => -1 );
            util::execute( 'git commit -m "bar" bar', rc => -1 );
            util::execute( 'git push', rc => -1 );
            # done
            chdir( '../../..' );

            # Multiple upstreams
            subdir( 'upstreams' );
            util::execute( 'git init --bare origin', rc => -1 );
            util::execute( 'git init --bare upstream', rc => -1 );
            util::execute( 'git clone origin workdir', rc => -1 );
            chdir( 'upstream' );
            my $upstream = getcwd();
            chdir( '../workdir' );
            util::execute( 'git remote add upstream ' . $upstream, rc => -1 );
            # One commit to origin
            open( $fh, '>>foo' );
            close( $fh );
            util::execute( 'git checkout -b origin', rc => -1 );
            util::execute( 'git add foo', rc => -1 );
            util::execute( 'git commit -m "foo" foo', rc => -1 );
            util::execute( 'git push --set-upstream origin origin', rc => -1 );
            # One commit to upstream2
            util::execute( 'git checkout -b upstream', rc => -1 );
            open( $fh, '>>bar' );
            close( $fh );
            util::execute( 'git add bar', rc => -1 );
            util::execute( 'git commit -m "bar" bar', rc => -1 );
            util::execute( 'git push --set-upstream upstream upstream', rc => -1 );
            # done
            chdir( '../../..' );

            # Branches
            subdir( 'branches' );
            util::execute( 'git init --bare upstream', rc => -1 );
            util::execute( 'git clone upstream workdir', rc => -1 );
            # creating commit and pushing to upstream
            chdir( 'workdir' );
            open( $fh, '>>foo' );
            close( $fh );
            util::execute( 'git add foo', rc => -1 );
            util::execute( 'git commit -m "foo" foo', rc => -1 );
            util::execute( 'git push', rc => -1 );
            # branch
            util::execute( 'git switch -c branch', rc => -1 );
            # creating commit and pushing to upstream
            open( $fh, '>>bar' );
            close( $fh );
            util::execute( 'git add bar', rc => -1 );
            util::execute( 'git commit -m "bar" bar', rc => -1 );
            util::execute( 'git push --set-upstream origin branch', rc => -1 );
            # done
            chdir( '../../..' );

            # Tags
            subdir( 'tags' );
            util::execute( 'git init --bare upstream', rc => -1 );
            util::execute( 'git clone upstream workdir', rc => -1 );
            # creating commit and pushing to upstream
            chdir( 'workdir' );
            open( $fh, '>>foo' );
            close( $fh );
            util::execute( 'git add foo', rc => -1 );
            util::execute( 'git commit -m "foo" foo', rc => -1 );
            util::execute( 'git tag -a -m "foo_msg" foo_tag', rc => -1 );
            open( $fh, '>>foo' );
            print( $fh '1' );
            close( $fh );
            util::execute( 'git commit -m "foo1" foo', rc => -1 );
            util::execute( 'git tag -a -m "foo1_msg" foo1_tag', rc => -1 );
            open( $fh, '>>foo' );
            print( $fh '2' );
            close( $fh );
            util::execute( 'git commit -m "foo2" foo', rc => -1 );
            util::execute( 'git tag -a -m "foo2_msg" foo2_tag', rc => -1 );
            util::execute( 'git tag light_tag', rc => -1 );
            open( $fh, '>>foo' );
            print( $fh '3' );
            close( $fh );
            util::execute( 'git commit -m "foo3" foo', rc => -1 );
            util::execute( 'git push --follow-tags', rc => -1 );
            # done
            chdir( '../../..' );

            dbg::leave();
        }
    }

    # 'devel test' runs a list of regression tests.
    package devel::test
    {
        our @ISA = 'devel';

        sub run()
        {
            dbg::enter();
            my $self = shift( @_ );
            my $pager = util::pager();
            my ( $rc, $output );
            %_catalog = (); # Disabling localization of error messages

            # preparing test executable
            ( my $testexe = q{#!/usr/bin/env bash

            o=1
            e=1

            for arg in "$@"
            do
                case $arg in
                    o)
                        echo "stdout$o"
                        o=$(($o + 1))
                        ;;
                    e)
                        echo "stderr$e" >&2
                        e=$(($e + 1))
                        ;;
                    [0-9])
                        exit $arg
                        ;;
                    s)
                        kill -s SIGINT $$
                        ;;
                esac
            done
            }) =~ s/^ {8}//mg;
            open( my $fh, '>', 'testexe' ) || die( "Error: Could not open 'testexe' for writing.\n" . $! );
            print( $fh $testexe );
            close( $fh );
            chmod( 0755, 'testexe' );
            print( $pager "Running self-tests:\n" );

            # util::execute()
            my $expected = "stdout1\nstdout2\nstdout3\nstderr1\nstdout4\nstdout5\nstdout6";
            eval { util::execute( 'nosuchcommand' ); }; die unless ( $@ =~ /.*Error:.* Failed to execute ‘nosuchcommand’\.\nCommand not found\./ );
            $rc = util::execute( './testexe o o o e o o o 0' ); die unless ( $rc == 0 );
            $rc = util::execute( './testexe o o o e o o o 1' ); die unless ( $rc == 1 );
            eval { util::execute( './testexe o o o e o o o s' ); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );
            $rc = util::execute( './testexe o o o e o o o 0', rc => 0 ); die unless ( $rc == 0 );
            $rc = util::execute( './testexe o o o e o o o 1', rc => 0 ); die unless ( $rc == 1 );
            eval { util::execute( './testexe o o o e o o o s', rc => 0 ); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );
            $rc = util::execute( './testexe o o o e o o o 0', rc => -1 ); die unless ( $rc == 0 );
            eval { util::execute( './testexe o o o e o o o 1', rc => -1 ); }; die unless ( $@ =~ /.*Error:.* Failed to execute ‘devel’\.\n.*‘\.\/testexe o o o e o o o 1’ returned ‘1’:\n$expected/ );
            eval { util::execute( './testexe o o o e o o o s', rc => -1 ); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );
            ( $rc, $output ) = util::execute( './testexe 0', out => 1 ); die unless ( ( $rc == 0 ) && ( $output eq '' ) );
            ( $rc, $output ) = util::execute( './testexe 1', out => 1 ); die unless ( ( $rc == 1 ) && ( $output eq '' ) );
            ( $rc, $output ) = util::execute( './testexe o o o e o o o 0', out => 1 ); die unless ( $rc == 0 && $output eq $expected );
            ( $rc, $output ) = util::execute( './testexe o o o e o o o 1', out => 1 ); die unless ( $rc == 1 && $output eq $expected );
            eval { util::execute( './testexe o o o e o o o s', out => 1 ); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );

            # executor
            my $exe;
            eval { $exe = new executor( 'nosuchcommand' ); }; die unless ( $@ =~ /.*Error:.* Failed to execute ‘nosuchcommand’\./ );
            $exe = new executor( './testexe o o o e o o o 0' );
            $rc = 1;
            while ( $exe->readline() )
            {
                chomp;
                die unless ( $_ eq "stdout$rc" );
                ++$rc;
            }
            $exe->close();
            die unless ( $exe->{ linecount } == 6 );
            die unless ( $exe->{ errors } eq "stderr1\n" );
            die unless ( $exe->{ rc } == 0 );
            $exe = new executor( './testexe o o o e o o o 1' ); $exe->close(); die unless ( $exe->{ rc } == 1 );
            $exe = new executor( './testexe o o o e o o o s' ); eval { $exe->close(); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );

            # util::subcommand()
            ( util::execute( "$0" ) == ::E_SUB_MISSING ) || die;
            ( util::execute( "$0 foo" ) == ::E_SUB_UNKNOWN ) || die;
            ( util::execute( "$0 worker" ) == ::E_SUB_UNKNOWN ) || die;
            ( util::execute( "$0 devel" ) == ::E_SUB_MISSING ) || die;

            # check_argv()
            @ARGV = (); util::check_argv( -1, -1 );
            @ARGV = (); util::check_argv( 0, 0 );
            @ARGV = ( 1 ); util::check_argv( -1, 1 );
            @ARGV = ( 1 ); util::check_argv( 0, 1 );
            @ARGV = ( 1 ); util::check_argv( 1, 1 );
            @ARGV = ( 1 ); util::check_argv( 1, 2 );
            @ARGV = ( 1 ); eval { util::check_argv( 0, 0 ); }; if ( $@ ) { die unless $@ =~ /.*Error:.* Too many arguments./; }
            @ARGV = ( ); eval { util::check_argv( 1, 1 ); }; if ( $@ ) { die unless $@ =~ /.*Error:.* Too few arguments./; }
            @ARGV = ( 1, 2 ); eval { util::check_argv( 1, 1 ); }; if ( $@ ) { die unless $@ =~ /.*Error:.* Too many arguments./; }
            @ARGV = ( 1, 2 ); eval { util::check_argv( 2, 2 ); }; if ( $@ ) { die unless $@ =~ /.*Error:.* Too few arguments./; }

            # init
            $self->init();
            dbg::msg( '* git_dir:             ' . $self->{ 'git_dir' } );
            dbg::msg( '* current_branch:      ' . $self->{ 'current_branch' } );
            dbg::msg( '* latest_pushed:       ' . $self->{ 'latest_pushed' } );

            # 'git'
            dbg::msg( '* git::uncommitted:    ' . git::uncommitted() );
            my ( $upstream, $push ) = git::upstream( $self->{ 'current_branch' } );
            dbg::msg( '* git::upstream:       ' . $upstream . ' - ' . $push );
            dbg::msg( '* git::remotes:        ' . join( ' - ', git::remotes() ) );
            dbg::msg( '* git::url:            ' . git::url( 'origin' ) );

            # Clean up
            unlink( 'testexe' );
            print( $pager "Done.\n" );
            dbg::leave();
        }
    }

    # 'devel todo' lists parts of Gim still requiring work.
    package devel::todo
    {
        our @ISA = 'devel';

        sub run()
        {
            dbg::enter();
            my $self = shift( @_ );
            my $pager = util::pager();
            open( my $script, '<', __FILE__ ) || die 'Failed to open script for inspection.';

            while ( <$script> )
            {
                if ( /TODO\x3a/ )
                {
                    print $pager $_;
                }
            }

            close( $script );
            dbg::leave();
        }
    }

$_help{ 'devel' } =
{
    category => 'local',
    about => 'Maintainer features',
    usage => q{gim devel <subcommand>
},
    help => q{Various features for maintainers of gim.

Available subcommands are:

 * catalog  --  writes a file ‘i-default.catalog’ with localizable strings

 * qtd      --  testing function for util::qtd

 * setup    --  creates a number of repositories for feature testing

 * test     --  runs a number of regression tests

 * todo     --  list TODO comments in script
}};

}

###################################################################
# 'diff' shows differences between commits, commits and the working
# copy etc.
package diff # TODO: Handling and documentation of @ARGV
{
    our @ISA = 'fileworker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        my $tool;
        my $toolhelp;
        Getopt::Long::GetOptions(
            'tool|t=s' => \$tool,
            'tools|tools-help|tool-help' => \$toolhelp
        );
        my $rc = 0;

        if ( defined( $toolhelp ) )
        {
            $self->toolhelp();
        }
        else
        {
            $self->init();
            my @args = util::qtd( @ARGV );

            if ( exists( $ENV{ GIM_DIFFTOOL } ) )
            {
                $tool = $ENV{ GIM_DIFFTOOL };
            }

            if ( defined( $tool ) )
            {
                $rc = util::execute( "git difftool --no-prompt --tool '$tool' @args", out => -1 );
            }
            else
            {
                my $opts = "-U3";

                if ( exists( $ENV{ GIM_DIFFOPTS } ) )
                {
                    $opts = $ENV{ GIM_DIFFOPTS };
                }

                my $pager = util::pager();
                my $exe = new executor( "git diff --color=$_COLOR --src-prefix=\"src:\" --dst-prefix=\"dst:\" $opts -- @ARGV", throw => 1 );

                while ( $exe->readline() )
                {
                    print( $pager $_ );
                }
            }

        }

        dbg::leave();
        return ::E_OK;
    }

    sub toolhelp()
    {
        dbg::enter();
        my $pager = util::pager();
        my $exe = new executor( 'git difftool --tool-help', throw => 1 );

        print( $pager util::text( 'Installed / available diff tools:' ) );

        while ( $exe->readline() )
        {
            if ( m/^	/ )
            {
                s/^	*([^\s]*)/    $1/;
                print( $pager $_ );
            }
            elsif ( m/^The following/ )
            {
                print( $pager "\n" . util::text( 'Supported but not installed:' ) );
            }
        }

        dbg::leave();
    }

$_help{ 'diff' } =
{
    category => 'info',
    about => 'Show differences',
    usage => q{gim diff [...]
    gim diff [--tool <tool> | -t <tool>] [...]
    gim diff [--tools | --tool-help]
},
    help => q{Shows differences between commits, commits and the
working copy, etc.

Unless otherwise specified, ‘git-diff’ is used with ‘--unified=3
--function-context’ as default options, which you can override by
setting the GIM_DIFFOPTS environment variable.

You can select a different tool than ‘git-diff’ with the ‘--tool’
option (short form ‘-t’). You can make that choice persistent by
setting the GIM_DIFFTOOL environment variable.

To get a list of available (and supported but unavailable) diff
tools, use either ‘--tools’ or ‘--tool-help’.
}};

}

###################################################################
# 'fetch' changes from upstream repository
package fetch
{
    our @ISA = 'worker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        util::check_argv( -1, 0 );
        $self->init();
        util::execute( 'git fetch --all --quiet', rc => -1, output => -1 );
        my $pager = util::pager();
        print( $pager util::text( 'Local repository up to date.' ) . "\n" );

        bless( $self, 'status' );
        $self->run();

        dbg::leave();
        return ::E_OK;
    }

$_help{ 'fetch' } =
{
    category => 'remote',
    about => 'Fetch changes from upstream',
    usage => q{gim fetch
},
    help => q{Fetch changes from upstream(s).

No changes will be applied to your working copy yet.
}};

}

###################################################################
# 'help' covers user documentation.
package help
{
    our @ISA = 'worker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        # 'help', 'help <cmd>', 'help topic <topic>'
        util::check_argv( 0, 2 );

        if ( @ARGV == 0 )
        {
            # 'help' -- basic self-documentation
            $self->_help();
        }
        else
        {
            my $cmd = shift( @ARGV );

            if ( $cmd ne 'topic' )
            {
                # 'help <subcommand>' -- subcommand documentation
                $self->_help_cmd( $cmd );
            }
            else
            {
                # 'help topic [<topic>]' -- general documentation
                $self->_help_topic();
            }
        }

        dbg::leave();
        return ::E_OK;
    }

    # 'help' prints a summary on subcommands on which help is available.
    sub _help()
    {
        dbg::enter();
        my $self = shift( @_ );
        my $pager = util::pager();
        print( $pager '  ' . util::text( 'Usage:' ) .
                      "    gim help <subcommand>\n\n" .
                      '  ' . util::text( 'Available subcommands:' ) .
                      "\n"
        );

        # List the subcommands under each %_category in their sort order
        foreach my $category ( sort { $_category{ $a }{ sortorder } <=> $_category{ $b }{ sortorder } } keys %_category )
        {
            print( $pager '  ' . util::text( $_category{ $category }{ about } ) );

            # The subcommands under each category are sorted alphabetically
            foreach my $subcommand ( sort keys %_help )
            {
                if ( ! $_help{ $subcommand }{ category } )
                {
                    util::throw( ::E_INTERNAL, "Error: Subcommand without category: $subcommand\n" );
                }

                # Print only subcommands of the current category
                if ( $_help{ $subcommand }{ category } ne $category )
                {
                    next;
                }

                printf( $pager "    gim %-19s %s\n", $subcommand, $_help{ $subcommand }{ about } );
            }

            print( $pager "\n" );
        }

        print( $pager '  ' . util::text( 'Additional help on Gim topics:' ) .
                      '    gim help topic [<topic>]' .
                      "\n"
        );

        dbg::leave();
    }

    # 'help <subcommand>' prints the help on a specific subcommand
    sub _help_cmd( $ )
    {
        dbg::enter();
        my $self = shift( @_ );
        util::check_argv( -1, 0 );

        if ( ! defined( $_help{ $_[0] }{ help } ) )
        {
            util::throw( ::E_SUB_UNKNOWN, util::text( 'Error: Unknown subcommand ‘[_1]’.', $_[0] ) .
                                          util::text( 'Try ‘[_1]’.', 'gim help' )
            );
        }

        my $pager = util::pager();
        print( $pager '  ' . util::text( 'Usage:' ) .
                      '    ' . $_help{ $_[0] }{ usage } .
                      "\n"
        );

        print( $pager Text::Wrap::fill( '  ', '  ', $_help{ $_[0] }{ help } ) );
        dbg::leave();
    }

    # 'help topic [<topic>]' prints help on general topics.
    sub _help_topic()
    {
        dbg::enter();
        my $self = shift( @_ );

        if ( @ARGV == 0 )
        {
            # Overview on topics
            my $pager = util::pager();
            print( $pager '  ' . util::text( 'Usage:' ) .
                          "    gim help topic <topic>\n\n" .
                          '  ' . util::text( 'Available topics:' )
            );

            foreach my $topic ( sort { $_topic{ $a }{ sortorder } <=> $_topic{ $b }{ sortorder } } keys %_topic )
            {
                printf( $pager "    %-23s %s\n", $topic, $_topic{ $topic }{ about } );
            }
        }
        else
        {
            # Help on a specific topic
            my $topic = shift( @ARGV );
            util::check_argv( -1, 0 );

            if ( ! $_topic{ $topic }{ help } )
            {
                util::throw( ::E_SUB_UNKNOWN, util::text( 'Error: Unknown topic ‘[_1]’.', $topic ) .
                                              util::text( 'Try ‘[_1]’.', 'gim help topic' )
                );
            }

            my $pager = util::pager();
            print( $pager '  ' .
                          $_topic{ $topic }{ about } .
                          "\n\n" .
                          Text::Wrap::fill( '  ', '  ', $_topic{ $topic }{ help } )
            );
        }

        dbg::leave();
    }

$_help{ help } =
{
    category => 'info',
    about => 'This help summary',
    usage => q{gim [help|--help]
    gim help <subcommand>
    gim <subcommand> --help
    gim help topic <topic>
},
    help => q{Gim comes with its own help functionality. Ideally,
this is all you should ever need.

Use ‘gim help’ to get an overview of the available subcommands, and
‘gim help <subcommand>’ to get the help on a specific subcommand.

There are also general help topics available. You get a list of
these with ‘gim help topic’, and display a specific topic with ‘gim
help topic <topic>’.
}};

}

###################################################################
# 'info' about given repository.
package info
{
    our @ISA = 'worker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        my $verbose;
        ::GetOptions(
            "verbose|v" => \$verbose
        );
        $self->init();
        my $pager = util::pager();
        my @remotes = split( "\n", util::execute( "git remote show -n", rc => -1, out => 1 ) );

        if ( @ARGV )
        {
            foreach ( @ARGV )
            {
                my $remote = $_;

                if ( ! grep( /^$remote$/, @remotes ) )
                {
                    util::throw( ::E_SYNTAX, util::text( "Error: No such remote: ‘[_1]’.", $_ ) );
                }
            }

            foreach ( @ARGV )
            {
                my $remote = $_;
                my ( $pattern ) = util::qtd( $remote . '/*' );

                printf( $pager "  %s%-12s%s  %s%s%s\n",
                               $_REMOTE_COL, $remote, $_RESET,
                               $_URL_COL,
                               util::execute( "git config remote.$remote.url", rc => -1, out => 1 ),
                               $_RESET
                      );

                foreach ( split( "\n", util::execute( "git branch --remotes --list --format='%(refname:lstrip=2)%(symref:lstrip=2)' $pattern", rc => -1, out => 1 ) ) )
                {
                    chomp;
                    my ( $ref, $symref ) = map { s/$remote\///r } split( "\x{1f}" );
                    printf( $pager "    %s%s%s", $_REF_COL, $ref, $_RESET );

                    if ( $symref )
                    {
                        printf( $pager "  ->  %s%s%s", $_SYMREF_COL, $symref, $_RESET );
                    }

                    print( $pager "\n" );

                    if ( $verbose && ! defined( $symref ) )
                    {
                        my $log = git::log( "--max-count=1 $ref" );
                        my ( $hash, $time_iso, $time_rel, $name, $mail, $refs, $msg ) = split( '\x{1f}', $log->readline() );
                        $log->close();
                        printf( $pager "$_TIME_COL%15s$_RESET  $_NAME_COL%-15s$_RESET  %s", $time_rel, $name, $msg );
                    }
                }
            }
        }
        else
        {
            if ( scalar( @remotes ) > 0 )
            {
                if ( scalar( @remotes ) == 1 )
                {
                    print( $pager util::text( "Remote:" ) );
                }
                else
                {
                    print( $pager util::text( "Remotes:" ) );
                }

                foreach ( @remotes )
                {
                    printf( $pager "  %s%-12s%s  %s%s%s\n",
                        $_REMOTE_COL, $_, $_RESET,
                        $_URL_COL,
                        util::execute( "git config remote.$_.url", rc => -1, out => 1 ),
                        $_RESET
                    );
                }

                print( $pager util::separator() );
            }

            my @heads = split( "\n", util::execute( "git for-each-ref --format \"%(refname:lstrip=2)\" refs/heads", rc => 0, out => 1 ) );
            print( $pager util::text( "Local Branches:            Tracking:" ) );

            foreach ( @heads )
            {
                if ( $_ eq $self->{ 'current_branch' } )
                {
                    printf( $pager "%s* ", $_CURRENT_COL );
                }
                else
                {
                    printf( $pager "  %s", $_LOCAL_COL );
                }

                printf( $pager "%-20s%s", $_, $_RESET );
                my ( $upstream, $push ) = git::upstream( $_ );

                if ( defined( $upstream ) || defined( $push ) )
                {
                    if ( defined( $upstream ) && defined( $push ) && ( $upstream eq $push ) )
                    {
                        printf( $pager "<->  %s%s",
                            $_UPSTREAM_COL, $upstream
                        );
                    }
                    else
                    {
                        if ( defined( $upstream ) )
                        {
                            printf( $pager "<-   %s%s%s  ",
                                $_UPSTREAM_COL, $upstream, $_RESET,
                            );
                        }

                        if ( defined( $push ) )
                        {
                            printf( $pager "->   %s%s",
                                $_PUSH_COL, $push
                            );
                        }
                    }
                }
                else
                {
                    printf( $pager "     %s%s%s",
                        $_REMOTE_COL, "(none)", $_RESET
                    );
                }

                printf( $pager "%s\n", $_RESET );

                if ( $verbose )
                {
                    my $log = git::log( "--max-count=1 $_" );
                    my ( $hash, $time_iso, $time_rel, $name, $mail, $refs, $msg ) = split( '\x{1f}', $log->readline() );
                    $log->close();
                    printf( $pager "$_TIME_COL%15s$_RESET  $_NAME_COL%-15s$_RESET  %s\n", $time_rel, $name, $msg );
                }
            }
        }

        dbg::leave();
        return ::E_OK;
    }

$_help{ 'info' } =
{
    category => 'info',
    about => 'Show info on remotes and branches',
    usage => q{gim info [--verbose|-v] [remote ...]
},
    help => q{Show info on remotes and branches.

In its parameterless version, shows the remotes of the repository
and all branches from it, including where that branch fetches and
pushes to.

If one or more remote names are given, a list of available branches
of that remote is given instead of a list of local branches.

The ‘--verbose’ / ‘-v’ option will additionally show the latest
commit from each branch.
}};

}

###################################################################
# 'init' creates a new repository.
package init
{
    our @ISA = 'fileworker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        my $type;
        Getopt::Long::GetOptions(
            'local|l' => \$type
        );
        util::check_argv( 1, 1 );
        my $repo = shift( @ARGV );

        if ( -e $repo )
        {
            util::throw( ::E_SYNTAX, util::text( 'Error: ‘[_1]’ already exists.', $repo ) );
        }

        if ( defined( $type ) )
        {
            $type = '';
        }
        else
        {
            $type = '--bare';
        }

        util::execute( "git init --quiet $type -- $repo", rc => -1, output => -1 );
        dbg::leave();
        return ::E_OK;
    }

$_help{ 'init' } =
{
    category => 'local',
    about => 'Create a new repository',
    usage => q{gim init [--local|-l] <repo>
},
    help => q{Create a new repository.

By default, a “bare” repository is created, which should then be
placed in an accessible and secure place (like a file / web / cloud
server) and be cloned with ‘gim clone’ to get a local repository
and working copy. This is the recommended procedure.

With the ‘--local’ option (short form ‘-l’), you create both a
repository and a working copy under the specified name, working
without an upstream repository.

Others could clone a local repository if you make it accessible in
some way, but this is not recommended.
}};

}

###################################################################
# 'log' displays change history
package log
{
    our @ISA = 'fileworker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        my $verbosity = 0;
        my $display_graph;
        my $graph_width = 0;
        my $log_option = '';
        ::GetOptions(
            "reference|r" => sub { $verbosity = -1; $log_option = 'reference'; },
            "all|a" => sub { $verbosity = 1; },
            "short|s" => sub { $verbosity = -1; $log_option = 'short'; },
            "medium|m" => sub { $verbosity = -1; $log_option = 'medium'; },
            "long|l" => sub { $verbosity = -1; $log_option = 'full'; },
            "verbose|v" => sub { $verbosity = -1; $log_option = 'fuller'; },
            "graph|g" => sub { $graph_width = 12; }
        );
        my $pager = util::pager();

        if ( $verbosity == -1 )
        {
            # Predefined formats of 'git log'
            if ( $graph_width != 0 )
            {
                $log_option .= ' --graph';
            }

            my $log = git::log( '--format=' . $log_option );

            while ( $log->readline() )
            {
                printf( $pager $_ );
            }

            $log->close();
        }
        else
        {
            if ( $graph_width != 0 )
            {
                $log_option .= '--graph';
            }

            my $log = git::log( $log_option );

            while ( $log->readline() )
            {
                chomp;
                my ( $hash, $time_iso, $time_rel, $name, $mail, $refs, $msg ) = split( '\x{1f}' );
                my $logline;

                if ( $graph_width != 0 )
                {
                    # Graph is not separated from hash and needs to
                    # be parsed out manually.
                    ( $logline, $hash ) = $hash =~ m/(.* )([^ ]*)/;
                    # Graph is colored; ANSI control codes are non-
                    # printing, which means that printf() field width
                    # will not work.
                    my $graph_padding = $graph_width - ( $logline =~ tr/_|\/\\* // );

                    if ( $graph_padding > 0 )
                    {
                        $logline .= ( ' ' x $graph_padding );
                    }
                }

                if ( defined( $time_iso ) )
                {
                    if ( $verbosity == 1 )
                    {
                        $logline .= sprintf( "$_TIME_COL%s$_RESET  $_HASH_COL%.8s$_RESET  $_NAME_COL%-15s$_RESET  %s  %s", $time_iso, $hash, $name, $msg, $refs );
                    }
                    else
                    {
                        $logline .= sprintf( "$_TIME_COL%15s$_RESET  $_NAME_COL%-15s$_RESET  %s  %s", $time_rel, $name, $msg, $refs );
                    }
                }

                print( $pager $logline . "\n" );
            }

            $log->close();
        }
        dbg::leave();
    }

$_help{ 'log' } =
{
    category => 'info',
    about => 'Show a commit log',
    usage => q{gim log [option]
},
    help => q{Show a commit log.

By default, shows a one-line format containing relative time,
author information, commit summary, and tree references.

With the ‘--all’ / ‘-a’ option, the default one-line format is
changed to show absolute timestamps instead of relative, and will
list the abbreviated commit hash as well.

The ‘--graph’ / ‘-g’ option adds a branch graph to the output of
any log output.

The remaining options correspond to predefined log formats
generated by the Git backend.

The options ‘--reference’ / ‘-r’, ‘--short’ / ‘-s’, and ‘--medium’
/ ‘-m’ correspond to the ‘git log’ options of the same name.

The ‘--long’ / ‘-l’ option corresponds to ‘git log --full’.

The ‘--verbose’ / ‘-v’ option corresponds to ‘git log --fuller’.
}};

}

###################################################################
# 'merge' branches
package merge
{
    our @ISA = 'branchworker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        util::check_argv( 1, -1 );
        $self->init();
        my @args = util::qtd( @ARGV );
        util::execute( "git merge @args", rc => -1 );
        dbg::leave();
        return ::E_OK;
    }

$_help{ 'merge' } =
{
    category => 'local',
    about => 'Merge branches',
    usage => q{gim merge ...
},
    help => q{Merge branches.
}};

}

###################################################################
# 'mkbranch' creates a new branch
package mkbranch
{
    our @ISA = 'worker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        util::check_argv( 1, 1 );
        $self->init();
        my $branch = shift( @ARGV );
        util::execute( "git branch -- $branch", rc => -1 );
        util::execute( "git switch -- $branch", rc => -1 );
        dbg::leave();
        return ::E_OK;
    }

$_help{ 'mkbranch' } =
{
    category => 'local',
    about => 'Create a new branch',
    usage => q{gim mkbranch <branch>
},
    help => q{Create a new branch.
}};

}

###################################################################
# 'mv' files
package mv
{
    our @ISA = 'fileworker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        util::check_argv( 2, -1 );
        $self->init();
        my @args = util::qtd( @ARGV );
        util::execute( "git mv @args", rc => -1 );
        dbg::leave();
        return ::E_OK;
    }

$_help{ 'mv' } =
{
    category => 'local',
    about => 'Move files',
    usage => q{gim mv ...
},
    help => q{Move files.
}};

}

###################################################################
# 'push' publishes your local commits
package push
{
    our @ISA = 'worker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        $self->init();
        my $command = 'git push --follow-tags --quiet';
        my $remote;
        Getopt::Long::GetOptions(
            'to|t=s' => \$remote
        );
        util::check_argv( -1, 0 );

        if ( $self->{ 'repo_status' } == ::S_DETACHED )
        {
            util::throw( ::E_UNABLE, util::text( 'Error: Cannot push an unnamed branch.' ) .
                                     util::text( 'Try ‘[_1]’.', 'gim help push' )
            );
        }

        my ( $upstream, $push ) = git::upstream( $self->{ 'current_branch' } );

        if ( ! defined( $push ) )
        {
            if ( ! defined( $remote ) )
            {
                util::throw( ::E_SYNTAX, util::text( 'Error: No remote to push to.' ) .
                                         util::text( 'Try ‘[_1]’.', 'gim help push' )
                );
            }
            else
            {
                my @remotes = split( "\n", util::execute( 'git remote show -n', rc => -1, out => 1 ) );

                if ( ! grep( /^$remote$/, @remotes ) )
                {
                    util::throw( ::E_SYNTAX, util::text( 'Error: Unknown remote: ‘[_1]’.', $remote ) );
                }

                my @branches = split( "\n", util::execute( 'git branch --remotes --list --format=\'%(refname:lstrip=3)\' ' . $remote . '/*', rc => -1, out => 1 ) );

                if ( grep( /^$self->{ 'current_branch' }$/, @branches ) )
                {
                    util::throw( ::E_SYNTAX, util::text( 'Error: ‘[_1]’ already exists on remote ‘[_2]’.', $self->{ 'current_branch' }, $remote ) );
                }

                $command .=  ' --set-upstream ' . $remote . ' ' . $self->{ 'current_branch' };
            }
        }

        util::execute( $command, rc => -1, output => -1 );
        dbg::leave();
        return ::E_OK;
    }

$_help{ 'push' } =
{
    category => 'remote',
    about => 'Publish local commits',
    usage => q{gim push [--to | -t <remote>]
},
    help => q{Publish local commits.

Note that this means you cannot modify those commits any longer
(without resorting to Git backend commands directly and running
into potential problems).

If you are working on an unnamed branch, you need to name that
branch (‘gim mkbranch <branch>’) before you can push it.

If the branch you are trying to push does not yet exist remotely,
you need to specify the remote, even if there is only one remote
currently configured. This is a safety feature.

If the branch you are trying to push already exists on the remote,
the push will fail.
}};

}

###################################################################
# 'remote' adding, removing, etc.
package remote
{
    our @ISA = 'worker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        my $subcommand = util::subcommand();
        $subcommand->run();
        dbg::leave();
        return ::E_OK;
    }

    package remote::add
    {
        our @ISA = 'remote';

        sub run()
        {
            dbg::enter();
            my @args = util::qtd( @ARGV );
            util::execute( "git remote add @args", rc => 0, out => 0 );
            dbg::leave();
        }
    }

    package remote::remove
    {
        our @ISA = 'remote';

        sub run()
        {
            dbg::enter();
            my @args = util::qtd( @ARGV );
            util::execute( "git remote remove @args", rc => 0, out => 0 );
            dbg::leave();
        }
    }

    package remote::rename
    {
        our @ISA = 'remote';

        sub run()
        {
            dbg::enter();
            my @args = util::qtd( @ARGV );
            util::execute( "git remote rename @args", rc => 0, out => 0 );
            dbg::leave();
        }
    }

$_help{ 'remote' } =
{
    category => 'remote',
    about => 'Handle remotes',
    usage => q{gim remote <subcommand>
},
    help => q{Handle remotes.

The following subcommands are available:

 * add    -- Add a remote.

 * remove -- Remove a remote.

 * rename -- Rename a remote.
}};

}

###################################################################
# 'revert' a local modification
package revert
{
    our @ISA = 'fileworker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        util::check_argv( 1, -1 );
        $self->init();
        util::execute( "git restore -- @ARGV", rc => -1 );
        dbg::leave();
        return ::E_OK;
    }

$_help{ 'revert' } =
{
    category => 'local',
    about => 'Revert local modification',
    usage => q{gim revert <filespec> [<filespec>...]
},
    help => q{Revert a local modification.
}};

}

###################################################################
# 'rm' files
package rm
{
    our @ISA = 'fileworker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        util::check_argv( 1, -1 );
        $self->init();
        my @args = util::qtd( @ARGV );
        util::execute( "git rm @args", rc => -1 );
        dbg::leave();
        return ::E_OK;
    }

$_help{ 'rm' } =
{
    category => 'local',
    about => 'Remove files from version control',
    usage => q{gim rm ...
},
    help => q{Remove files from version control.
}};

}

###################################################################
# 'rmbranch' creates a new branch
package rmbranch
{
    our @ISA = 'branchworker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        util::check_argv( 1, -1 );
        $self->init();
        my $branch = shift( @ARGV );

        if ( $branch eq $self->{ 'current_branch' } )
        {
            util::throw( ::E_UNABLE, util::text( "Error: Cannot act on current branch." ) );
        }

        util::execute( "git branch -D -- $branch", rc => -1 );
        dbg::leave();
        return ::E_OK;
    }

$_help{ 'rmbranch' } =
{
    category => 'local',
    about => 'Delete a local branch',
    usage => q{gim rmbranch <branch>
},
    help => q{Delete a local branch.
}};

}

###################################################################
# 'stash' for local changes
package stash
{
    our @ISA = 'worker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        my $subcommand = util::subcommand();
        $subcommand->run();
        dbg::leave();
        return ::E_OK;
    }

    package stash::apply
    {
        our @ISA = 'stash';

        sub run()
        {
            dbg::enter();
            my @args = util::qtd( @ARGV );
            util::execute( "git stash apply @args", rc => 0, out => 0 );
            dbg::leave();
        }
    }

    package stash::branch
    {
        our @ISA = 'stash';

        sub run()
        {
            dbg::enter();
            my @args = util::qtd( @ARGV );
            util::execute( "git stash branch @args", rc => 0, out => 0 );
            dbg::leave();
        }
    }

    package stash::clear
    {
        our @ISA = 'stash';

        sub run()
        {
            dbg::enter();
            my @args = util::qtd( @ARGV );
            util::execute( "git stash clear @args", rc => 0, out => 0 );
            dbg::leave();
        }
    }

    package stash::drop
    {
        our @ISA = 'stash';

        sub run()
        {
            dbg::enter();
            my @args = util::qtd( @ARGV );
            util::execute( "git stash drop @args", rc => 0, out => 0 );
            dbg::leave();
        }
    }

    package stash::list
    {
        our @ISA = 'stash';

        sub run()
        {
            dbg::enter();
            my @args = util::qtd( @ARGV );
            util::execute( "git stash list @args", rc => 0, out => 0 );
            dbg::leave();
        }
    }

    package stash::pop
    {
        our @ISA = 'stash';

        sub run()
        {
            dbg::enter();
            my @args = util::qtd( @ARGV );
            util::execute( "git stash pop @args", rc => 0, out => 0 );
            dbg::leave();
        }
    }

    package stash::push
    {
        our @ISA = 'stash';

        sub run()
        {
            dbg::enter();
            my @args = util::qtd( @ARGV );
            util::execute( "git stash push @args", rc => 0, out => 0 );
            dbg::leave();
        }
    }

    package stash::show
    {
        our @ISA = 'stash';

        sub run()
        {
            dbg::enter();
            my @args = util::qtd( @ARGV );
            util::execute( "git stash show @args", rc => 0, out => 0 );
            dbg::leave();
        }
    }

$_help{ 'stash' } =
{
    category => 'local',
    about => 'Stash for local changes',
    usage => q{gim stash <subcommand>
},
    help => q{Stash for local changes.

The following subcommands are available:

 * push   -- Push local commits on the stash stack.

 * list   -- List the stash stack.

 * show   -- Inspect one entry on the stash stack.

 * drop   -- Remove an entry from the stash stack.

 * clear  -- Remove all entries from the stash stack.

 * apply  -- Apply an entry from the stash stack to the working directory.

 * pop    -- As ‘apply’, but removes the entry from the stash stack if applying did not result in errors.

 * branch -- Turn a stash entry into a new branch.
}};

}

###################################################################
# 'status' gives information about the repository's current state
package status
{
    our @ISA = 'worker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        util::check_argv( -1, 0 );
        $self->init();
        my $pager = util::pager();

        # ---------------------------------------------------------
        print( $pager util::text( 'Current branch:' ) );

        printf( $pager '  %s%-20s%s',
                       $_CURRENT_COL, $self->{ 'current_branch' }, $_RESET );

        if ( $self->{ 'repo_status' } != ::S_DETACHED )
        {
            ( $self->{ 'upstream' }, $self->{ 'push' } ) = git::upstream( $self->{ 'current_branch' } );

            if ( defined( $self->{ 'upstream' } ) )
            {
                if ( defined( $self->{ 'push' } ) && ( $self->{ 'upstream' } ne $self->{ 'push' } ) )
                {
                    printf( $pager '  <-  %s%s%s  ->  %s%s%s',
                                   $_UPSTREAM_COL, $self->{ 'upstream' }, $_RESET,
                                   $_PUSH_COL, $self->{ 'push' }, $_RESET );
                }
                else
                {
                    printf( $pager '  <->  %s%s%s',
                                   $_UPSTREAM_COL, $self->{ 'upstream' }, $_RESET );
                }
            }
        }

        print( $pager "\n" );

        # ---------------------------------------------------------
        if ( defined( $self->{ 'upstream' } ) )
        {
            my $log = git::log( ( defined( $self->{ 'current_branch' } ) ? 'HEAD..' : '' ) . '@{upstream}' );

            while ( $log->readline() )
            {
                if ( $log->{ 'linecount' } == 1 )
                {
                    print( $pager util::text( 'Unmerged:' ) );
                }

                chomp;
                my ( $hash, $time_iso, $time_rel, $name, $mail, $refs, $msg ) = split( '\x{1f}' );
                printf( $pager "  %s%15s%s  %s%-15s%s  %s\n",
                               $_TIME_COL, $time_rel, $_RESET,
                               $_NAME_COL, $name, $_RESET,
                               $msg );
            }

            $log->close();
        }

        # ---------------------------------------------------------
        if ( defined( $self->{ 'upstream' } ) )
        {
            if ( defined( $self->{ 'current_branch' } ) )
            {
                my $log = git::log( '@{push}..HEAD' );

                while ( $log->readline() )
                {
                    if ( $log->{ 'linecount' } == 1 )
                    {
                        print( $pager util::text( 'Unpublished:' ) );
                    }

                    chomp;
                    my ( $hash, $time_iso, $time_rel, $name, $mail, $refs, $msg ) = split( '\x{1f}' );
                    printf( $pager "  %s%15s%s                   %s\n",
                                   $_TIME_COL, $time_rel, $_RESET,
                                   $msg );
                }

                $log->close();
            }
        }

        # ---------------------------------------------------------
        my $stashed = new executor( "git stash list --pretty=format:'%ai\x{1f}%ar\x{1f}%aN\x{1f}%gd\x{1f}%s'", throw => 1 );

        while ( $stashed->readline() )
        {
            if ( $stashed->{ 'linecount' } == 1 )
            {
                print( $pager util::text( 'Stashed:' ) );
            }

            chomp;
            my ( $time_iso, $time_rel, $name, $sel, $msg ) = split( '\x{1f}' );
            $msg =~ s/^WIP on ([^:]*): [a-f0-9]* /Work on $1: /;
            $sel =~ s/stash@\{([0-9]])\}/$1/;
            printf( $pager "  %s%15s%s  %sstash #%-3s%s       %s\n",
                           $_TIME_COL, $time_rel, $_RESET,
                           $_STASH_COL, $sel, $_RESET,
                           $msg );
        }

        $stashed->close();

        # ---------------------------------------------------------
        my $changes = new executor( "git -c color.status=$_COLOR status --short", throw => 1 );

        while ( $changes->readline() )
        {
            if ( $changes->{ 'linecount' } == 1 )
            {
                print( $pager util::text( 'Uncommitted:' ) );
            }

            print( $pager '  ' . $_RESET . $_ );
        }

        $changes->close();

        dbg::leave();
        return ::E_OK;
    }

$_help{ 'status' } =
{
    category => 'info',
    about => 'Get general status',
    usage => q{gim status
},
    help => q{Get general status information.

This includes:

The name of the current branch, plus the name of the associated
upstream branch and (if configured) push branch.

A list of commits already fetched from upstream which have not
yet been merged into your working copy, if any. (See ‘gim help
update’ for details.)

A list of local commits not yet published, if any. (See ‘gim
help push’ for details.)

A list of stashed changes, if any. (See ‘gim help stash’ for
details.)

A list of uncommited changes, if any. (See ‘gim help commit’
for details.)
}};

}

###################################################################
# 'switch' to a different branch
package switch
{
    our @ISA = 'branchworker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        $self->init();
        my $detach = '';
        Getopt::Long::GetOptions(
            'detach|d' => sub { $detach = '--detach'; }
        );
        util::check_argv( 1, 1 );
        my $branch = shift( @ARGV );
        util::execute( "git switch $detach -- $branch", rc => -1 );
        dbg::leave();
        return ::E_OK;
    }

$_help{ 'switch' } =
{
    category => 'local',
    about => 'Switch to given branch',
    usage => q{gim switch [--detach|-d] <branch>
},
    help => q{Switch working copy to given branch.

Use the ‘--detach’ / ‘-d’ option if you want to detach from
existing branches. (Check ‘gim help topic detached’ for details
on “detached HEAD” state.)
}};

}

###################################################################
# 'tag' commits
package tag
{
    our @ISA = 'worker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        util::check_argv( 1, -1 );
        $self->init();
        my $subcommand = util::subcommand();
        $subcommand->run();
        dbg::leave();
        return ::E_OK;
    }

    package tag::add
    {
        our @ISA = 'tag';

        sub run()
        {
            dbg::enter();
            my $command = 'git tag';
            my $file;
            my $msg;
            my $light;
            Getopt::Long::GetOptions(
                'file|F=s'    => \$file,
                'message|m=s' => \$msg,
                'light|l'     => \$light
            );
            util::check_argv( 1, 1 );

            if ( defined( $file ) && defined( $msg ) )
            {
                util::throw( ::E_SYNTAX, util::text( 'Error: Conflicting options ‘[_1]’ and ‘[_2]’.', '--file', '--message' ) );
            }

            if ( defined( $light ) )
            {
                if ( defined( $file ) || defined( $msg ) )
                {
                    util::throw( ::E_SYNTAX, util::text( 'Error: Conflicting options ‘[_1]’ and ‘[_2]’.', '--light', ( defined( $file ) ? '--file' : '--message' ) ) );
                }
            }
            else
            {
                $command .= ' -a';
            }

            if ( defined( $file ) )
            {
                util::check_filespecs( ::E_NOTFILE, $file );
                ( $file ) = util::qtd( $file );
                $command .= " --file $file";
            }

            if ( defined( $msg ) )
            {
                ( $msg ) = util::qtd( $msg );
                $command .= " --message $msg";
            }

            my @args = util::qtd( @ARGV );
            util::execute( $command . " @args", rc => -1, out => -1 );
            dbg::leave();
        }
    }

    package tag::delete
    {
        our @ISA = 'tag';

        sub run()
        {
            dbg::enter();
            util::check_argv( 1, -1 );
            my @args = util::qtd( @ARGV );
            util::check_tags( @args );
            util::execute( "git tag -d @args", rc => -1 );
            dbg::leave();
        }
    }

    package tag::list
    {
        our @ISA = 'tag';

        sub run()
        {
            dbg::enter();
            my $all;
            Getopt::Long::GetOptions(
                'all|a' => \$all,
            );
            my @args = ();

            if ( @ARGV )
            {
                foreach ( @ARGV )
                {
                    push( @args, util::qtd( "refs/tags/$_" ) );
                }
            }
            else
            {
                @args = ( "refs/tags/*" );
            }

            my $pager = util::pager();
            my $list = new executor( "git for-each-ref --sort=-taggerdate --format='%(objectname)\x{1f}%(*objectname:short=8)\x{1f}%(taggerdate:iso)\x{1f}%(taggerdate:relative)\x{1f}%(taggername)\x{1f}%(taggeremail)\x{1f}%(refname:lstrip=2)\x{1f}%(contents:subject)\x{1f}%(contents:body)' @args" );

            while ( $list->readline() )
            {
                my ( $taghash, $hash, $time_iso, $time_rel, $name, $mail, $tag, $subject, $body ) = split( '\x{1f}' );

                if ( $hash eq '' )
                {
                    # Lightweight tags have no hash of their own
                    # so the object hash *is* already the commit
                    $hash = $taghash;
                    # Also, their contents:subject is that of the
                    # tagged commit (obviously).
                    $subject = "\b\b";
                    $body = '';
                }

                if ( defined( $all ) )
                {
                    printf( $pager "$_TIME_COL%25s$_RESET  $_HASH_COL%.8s$_RESET  $_NAME_COL%-15s$_RESET  %s  ($_TAG_COL%s$_RESET)\n", $time_iso, $hash, $name, $subject, $tag );
                }
                else
                {
                    printf( $pager "$_TIME_COL%15s$_RESET  $_NAME_COL%-15s$_RESET  %s  ($_TAG_COL%s$_RESET)\n", $time_rel, $name, $subject, $tag );
                }
            }

            $list->close();
            dbg::leave();
        }
    }

$_help{ 'tag' } =
{
    category => 'local',
    about => 'Handle commit tags',
    usage => q{gim tag add [--message | -m <msg>] <tag> [<revspec>]
    gim tag add [--file | -F <filename>] <tag> [<revspec>]
    gim tag add --light | -l <tag> [<revspec>]

    gim tag delete <tag>
    gim tag list [--all | -a] <pattern>
},
    help => q{Handle commit tags.

A tag is an alias applied to an existing commit. It allows to
refer to that specific commit by its symbolic tag name, so you
do not have to refer to its hash value anymore.

There are two different kinds of tags: Annotated, meaning these
are given a message similar to a commit message; and lightweight,
which are not given such a message. Within Gim we use lightweight
tags for local use only and never push them to remotes, whereas
annotated tags are always pushed.

Note that this is a Gim convention only.

The following subcommands are available:

 * add    -- Add a tag.

Without options, an editor is opened for you to enter the tag
message. With the ‘--file’ / ‘-F’ option, the contents of the
file specified will be used as tag message. With the ‘--message’ /
‘-m’ option, the passed string is used as the tag message.

With the ‘--light’ / ‘-l’ option, no tag message is given, and
a lightweight tag is created.

For each of these commands, you need to specify the tag name. By
default that tag name is applied to the HEAD commit. You may
specify a different commit (through its hash value or an already
existing other tag) to apply the tag to.

 * delete -- Delete a tag.

 * list   -- List tags.

Lists tags similar to ‘git log’. By default, shows a one-line
format containing relative time, tagger information, tag summary,
and tag name.

With the ‘--all’ / ’-a’ option, the default one-line format is
changed to show absolute timestamps instead of relative, and will
list the abbreviated hash of the tagged commit as well.
}};

}

###################################################################
# 'uncommit' allows to undo local (unpublished) commits.
package uncommit
{
    our @ISA = 'worker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        $self->init();
        my $yes;
        Getopt::Long::GetOptions(
            'yes|y' => \$yes
        );
        util::check_argv( -1, 0 );
        my $logspec = "HEAD";
        my @commits;

        if ( defined( $self->{ 'latest_pushed' } ) )
        {
            $logspec = '@{push}^1..HEAD';
        }

        my $log = git::log( $logspec );

        while ( $log->readline() )
        {
            chomp;
            push( @commits, $_ );
        }

        $log->close();

        if ( scalar( @commits ) < 2 )
        {
            util::throw( ::E_UNABLE, util::text( "Error: Nothing to uncommit." ) );
        }
        else
        {
            my ( $hash, $time_iso, $time_rel, $name, $mail, $refs, $msg );

            if ( ! defined( $yes ) )
            {
                print( "\n" . util::text( "Really undo this commit?" ) );
                ( $hash, $time_iso, $time_rel, $name, $mail, $refs, $msg ) = split( '\x{1f}', $commits[0] );
                printf( "%s%s  %15s%s  %s\n", $_TIME_COL, $time_iso, $time_rel, $_RESET, $msg );
                print( util::text( "This will reset commit history to:" ) );
                ( $hash, $time_iso, $time_rel, $name, $mail, $refs, $msg ) = split( '\x{1f}', $commits[1] );
                printf( "%s%s  %15s%s  %s\n", $_TIME_COL, $time_iso, $time_rel, $_RESET, $msg );

                if ( util::confirmation() )
                {
                    $yes = 1;
                }
            }

            if ( defined( $yes ) )
            {
                util::execute( 'git reset --mixed ' . $hash, rc => -1 );
            }
        }

        dbg::leave();
        return ::E_OK;
    }

$_help{ 'uncommit' } =
{
    category => 'local',
    about => 'Undo local commit',
    usage => q{gim uncommit [--yes|-y]
},
    help => q{Undo latest local (unpublished) commit.

Removes the latest local commit from the commit history.

Local changes remain untouched.

By default this will ask for confirmation, stating the commit you
are about to undo and the commit you will reset your commit history
to. With the ‘--yes’ / ‘-y’ option, no confirmation will be asked
for.
}};

}

###################################################################
# 'update' local repository and working directory with incoming
# changes.
package update
{
    our @ISA = 'worker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        $self->init();
        util::check_argv( -1, 0 );
        my $pager = util::pager();

        # Are there unmerged commits in the first place?
        if ( $self->{ 'repo_status' } != ::S_DETACHED )
        {
            ( $self->{ 'upstream' }, $self->{ 'push' } ) = git::upstream( $self->{ 'current_branch' } );

            if ( defined( $self->{ 'upstream' } ) )
            {
                my $log = git::log( ( defined( $self->{ 'current_branch' } ) ? 'HEAD..' : '' ) . '@{upstream}' );

                if ( $log->readline() )
                {

                    # Are there local changes that need to be stashed?
                    my $changes = util::execute( 'git status --short', rc => -1, out => 1 );

                    if ( $changes )
                    {
                        util::execute( "git stash --include-untracked --quiet --message \"‘gim update’ temporary\"", rc => -1, output => -1 );
                    }

                    # Do the actual merge
                    util::execute( 'git rebase --quiet', rc => -1, output => -1 );

                    # Unstash
                    if ( $changes )
                    {
                        util::execute( 'git stash pop --quiet', rc => -1, output => -1 );
                    }

                    print( $pager util::text( 'Changes merged.' ) . "\n" );
                }
                else
                {
                    print( $pager util::text( 'No unmerged changes.' ) . "\n" );
                }
            }
            else
            {
                print( $pager util::text( 'No upstream.' ) . "\n" );
            }
        }
        else
        {
            print( $pager util::text( 'Repository in “detached HEAD” state, cannot update.' ) . "\n" );
        }

        bless( $self, 'status' );
        $self->run();

        dbg::leave();
        return ::E_OK;
    }

$_help{ 'update' } =
{
    category => 'local',
    about => 'Update local repository',
    usage => q{gim update
},
    help => q{Update local repository and working directory.

This stashes any local changes, applies incoming commits, and then
reapplies the stash.
}};

}

###################################################################
###################################################################
$_topic{ paging } =
{
    sortorder => 0,
    about => q{Gim Output Paging},
    help => q{Gim passes its output through a pager, so that output
stops each time the screen is filled up, waiting for you to press a
key to continue.

The default pager used is ‘less’. You can override the pager used
by setting the GIM_PAGER environment variable.

The ‘less’ utility accepts a number of options controlling its
behavior. These options can be set globally by setting the LESS
environment variable. If this variable is set, Gim respects its
setting. If LESS is not set, Gim will use ‘--quit-if-one-screen’,
‘--quit-at-eof’, ‘--RAW-CONTROL-CHARS’, ‘--chop-long-lines’, and
‘--no-init’ (‘-FeRSX’).
}};

###################################################################
$_topic{ detached } =
{
    sortorder => 1,
    about => q{Detached HEAD / Unnamed Branch},
    help => q{Usually ‘HEAD’ is a symbolic reference to the latest
commit -- the head commit -- of whatever your current branch is.
When you ‘gim switch’ to a different branch, ‘HEAD’ (and your
working copy) is updated accordingly.

Sometimes it is desirable to point your working directory at a
previous state. Your ‘HEAD’ will no longer refer to any existing
branch's head; it will be “detached”. Another way to think about
it would be that you created a new branch, branching off at that
previous point in the commit history. Any commits you would commit
while in that state would go on that as-of-yet unnamed branch.

In this state, ‘gim status’ will show something like
‘<unnamed:a7f653c>’ (with the appropriate commit hash) instead of
the (unavailable) current branch name.

You can either name the branch (‘git mkbranch <branch>’), or
abandon it by ‘gim switch’ to a previously existing branch.
}};

###################################################################
###################################################################
package gim;

print( $_RESET );
my $command;
Getopt::Long::GetOptions(
    'debug:s' => \&dbg::init,
    'help|h' => sub { $command = help->new(); }
);

l10n::init();

$command = util::subcommand() unless ( $command );
$command->run();

# $ git rev-parse HEAD
# dc04d9b95c43534625c2b5026a5585418f4d711b

# gim1 util::refs
# $ git show-ref
# dc04d9b95c43534625c2b5026a5585418f4d711b refs/heads/main
# dc04d9b95c43534625c2b5026a5585418f4d711b refs/remotes/origin/HEAD
# dc04d9b95c43534625c2b5026a5585418f4d711b refs/remotes/origin/main
# ...auch alle Tags.

# branch_info
# - git rev-parse --abbrev-ref --symbolic-full-name $branch@{upstream}
# - git rev-parse --abbrev-ref --symbolic-full-name $branch@{push}

# sub state()
# {
#     dbg::enter();
#     my $gitdir = root();
#     my $state;
#
#     if ( ! $gitdir )
#     {
#         print( STDERR l10n::text( 'Error: Command requires valid working copy.' ) );
#         exit( ::E_NO_WORKDIR );
#     }
#
#     if ( -d "$gitdir/rebase-apply" )
#     {
#         if ( -f "$gitdir/rebase-apply/rebasing" )
#         {
#             $state = 'REBASE';
#         }
#         elsif ( -f "$gitdir/rebase-apply/applying" )
#         {
#             $state = 'APPLY';
#         }
#         else
#         {
#             $state = 'APPLY OR REBASE';
#         }
#     }
#     elsif ( -f "$gitdir/rebase-merge/interactive" )
#     {
#         $state = 'INTERACTIVE REBASE';
#     }
#     elsif ( -d "$gitdir/rebase-merge" )
#     {
#         $state = 'MERGE REBASE';
#     }
#     elsif ( -f "$gitdir/MERGE_HEAD" )
#     {
#         $state = 'MERGE';
#     }
#     elsif ( -f "$gitdir/BISECT_LOG" )
#     {
#         $state = 'BISECT';
#     }
#
#     dbg::leave();
#     return $state;
# }
