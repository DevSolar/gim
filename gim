#!/usr/bin/perl

use strict;
use warnings;
use utf8;
use open( ':std', ':encoding(UTF-8)' );

use Getopt::Long     qw( :config posix_default permute pass_through );

###################################################################
###################################################################
# Exit Codes
use constant E_OK            =>  0;
use constant E_SUB_MISSING   =>  1;  # No subcommand given
use constant E_SUB_UNKNOWN   =>  2;  # Subcommand unknown
use constant E_EXECUTE_FAIL  =>  3;  # Execution failure
use constant E_SIG_INTERRUPT =>  4;  # Interrupted by signal
use constant E_UNEXPECTED    =>  5;  # Unexpected backend error
use constant E_ARGUMENTS     =>  6;  # Wrong number of arguments
use constant E_NOTFILE       =>  7;  # Not a regular file
use constant E_NOTFILEORDIR  =>  8;  # Not a regular file or directory
use constant E_NOTTRACKED    =>  9;  # Not a file under version control
use constant E_INTERNAL      => 10;  # Internal error

###################################################################
# Colors

# Default is 'no color'
my $_COLOR   = 'never';
my $_RED     = '';
my $_GREEN   = '';
my $_BLUE    = '';
my $_YELLOW  = '';
my $_MAGENTA = '';
my $_CYAN    = '';
my $_RESET   = '';

if ( -t STDOUT )
{
    # If we are printing to terminal, *do* use colors.
    use Term::ANSIColor  qw( :constants );
    $_COLOR   = 'always';
    $_RED     = ::RED;
    $_GREEN   = ::GREEN;
    $_BLUE    = ::BLUE;
    $_YELLOW  = ::YELLOW;
    $_MAGENTA = ::MAGENTA;
    $_CYAN    = ::CYAN;
    $_RESET   = ::RESET;
}

# Color Scheme
my $_OK_COL       = $_GREEN;
my $_ERROR_COL    = $_RED;
my $_WARN_COL     = $_YELLOW;

###################################################################
###################################################################
# 'dbg' provides call stack trace / log message functionality.
# With 'gim ... --debug', trace log is written to terminal. With
# 'gim ... --debug <filename>', trace log is written to file.
# Note that '--debug [<filename>]' needs to be at the end of the
# command line due to the way argument parsing works.
package dbg
{
    my $_dbg;
    our $_indent = 0;
    # NOT setting these with the other colors at the top of the
    # script, as debug coloring depends on whether *debug* goes to
    # terminal or file, not the general output.
    my $_dbg_color = ::MAGENTA;
    my $_dbg_clear = ::CLEAR;

    # Called from main's GetOptions, with an optional log filename
    # as second argument. (First argument of the function is always
    # 'debug'.) Initializes the debug file handle $_dbg.
    sub init( $;$ )
    {
        if ( length( $_[1] ) )
        {
            # Logging to file
            if ( ! open( $_dbg, '>', $_[1] ) )
            {
                $_dbg = *STDOUT;
                print( $_dbg util::text( 'Warning: Could not open debug output file ‘[_1]’.', $_[1] ) );
            }
            else
            {
                $_dbg_color = '';
                $_dbg_clear = '';
            }
        }
        else
        {
            $_dbg = *STDOUT;

            if ( ! -t STDOUT )
            {
                $_dbg_color = '';
                $_dbg_clear = '';
            }
        }
    }

    # Called upon subroutine entry. Prints stack trace entry and
    # increases indentation of subsequent entries.
    sub enter()
    {
        if ( defined( $_dbg ) )
        {
            package DB;
            print( $_dbg ( ' ' x $_indent ) . $_dbg_color . '>> ' . (caller(1))[3] . '(' );

            if ( (caller(1))[4] )
            {
                print( $_dbg ' ' . join( ', ', map { defined ? qq("$_") : '<undef>' } @DB::args ) . ' ' );
            }

            print( $_dbg ")$_dbg_clear\n" );
            $_indent += 3;
        }
    }

    # Print a log entry at current indentation.
    sub msg( $ )
    {
        if ( defined( $_dbg ) )
        {
            for ( split( "\n", $_[0] ) )
            {
                print( $_dbg ( ' ' x $_indent ) . $_dbg_color . $_ . $_dbg_clear . "\n" );
            }
        }
    }

    # Called before subroutine exit. Prints stack trace entry and
    # decreases indentation of subsequent entries.
    sub leave()
    {
        if ( defined( $_dbg ) )
        {
            $_indent -= 3;
            print( $_dbg ( ' ' x $_indent ) . $_dbg_color . '<< ' . (caller(1))[3] . $_dbg_clear . "\n" );
        }
    }

    # Close the debug file handle before exit.
    END
    {
        if ( defined( $_dbg ) && fileno( $_dbg ) )
        {
            dbg::msg( 'dbg::END' );
            close( $_dbg );
        }
    }
}

###################################################################
###################################################################
# 'util' covers any utility subroutines.
package util
{
    # Check that the number of arguments (remaining @ARGV) is no
    # less than the first and no more than the second argument.
    # -1 means 'no check'.
    sub check_argv( $$ )
    {
        dbg::enter();

        if ( @ARGV < $_[0] )
        {
            util::throw( ::E_ARGUMENTS, util::text( 'Error: Too few arguments.' ) );
        }

        if ( ( $_[1] > -1 ) && ( @ARGV > $_[1] ) )
        {
            util::throw( ::E_ARGUMENTS, util::text( 'Error: Too many arguments.' ) );
        }

        dbg::leave();
    }

    # Throws if one of the arguments does not refer to a file.
    # Generates warnings for symbolic links, which are not portable
    # across platforms.
    sub check_files( @ )
    {
        dbg::enter();

        foreach ( @_ )
        {
            dbg::msg( "checking ‘$_’" );

            if ( ! -f $_ )
            {
                util::throw( ::E_NOTFILE, util::text( 'Error: ‘[_1]’ is not a regular file.', $_ ) );
            }

            if ( -l $_ )
            {
                print( util::text( 'Warning: ‘[_1]’ is a symbolic link, which is not portable.', $_ ) );
            }
        }

        dbg::leave();
    }

    # Check that the list of arguments violates a predicate given
    # as first parameter. Returns if all arguments check out,
    # throws otherwise. Generates warnings for symbolic links,
    # which are not portable across platforms.
    # Predicates:
    # ::E_NOTFILE      -- if item is regular file
    # ::E_NOTFILEORDIR -- if item is regular file or directory
    # ::E_NOTTRACKED   -- if item is not under version control
    sub check_filespecs( $@ )
    {
        dbg::enter();
        my $func = shift( @_ );

        foreach ( @_ )
        {
            my $filespec = $_;
            dbg::msg( "checking ‘$filespec’" );

            use feature qw( switch );
            no warnings qw( experimental::smartmatch );

            given ( $func )
            {
                when ( ::E_NOTFILE )
                {
                    if ( ! -f $filespec )
                    {
                        util::throw( ::E_NOTFILE, util::text( 'Error: ‘[_1]’ is not a regular file.', $filespec ) );
                    }
                }
                when ( ::E_NOTFILEORDIR )
                {
                    if ( ! -f $filespec && ! -d $filespec )
                    {
                        util::throw( ::E_NOTFILEORDIR, util::text( 'Error: ‘[_1]’ is neither regular file nor directory.', $filespec ) );
                    }
                }
                when ( ::E_NOTTRACKED )
                {
                    if ( util::execute( "git ls-files --error-unmatch $filespec" ) )
                    {
                        util::throw( ::E_NOTTRACKED, util::text( 'Error: ‘[_1]’ is not under version control.', $filespec ) );
                    }
                }
                default
                {
                    util::throw( ::E_INTERNAL, 'Error: Unknown predicate in check_filespecs().' )
                }
            }

            if ( -l $filespec )
            {
                print( util::text( 'Warning: ‘[_1]’ is a symbolic link, which is not portable.', $_ ) );
            }
        }

        dbg::leave();
    }

    # Check return code from external calls
    sub check_rc( $$ )
    {
        dbg::enter();
        my ( $rc, $command ) = @_;

        # Mapping of signal numbers to signal names for error messages
        use Config '%Config';
        my @sig_names;
        @sig_names[ split( ' ', $Config{ sig_num } ) ] = split( ' ', $Config{ sig_name } );

        if ( $rc != 0 )
        {
            if ( $rc == -1 )
            {
                util::throw( ::E_EXECUTE_FAIL, util::text( 'Error: Failed to execute ‘[_1]’.', 'sh' ) );
            }
            elsif ( $rc & 127 )
            {
                $rc &= 127;
                util::throw( ::E_SIG_INTERRUPT, util::text( 'Error: ‘[_1]’ interrupted by signal [_2] ‘[_3]’.', $command, $rc, $sig_names[ $rc ] ) );
            }
            else
            {
                $rc = $rc >> 8;

                if ( $rc > 128 )
                {
                    $rc -= 128;
                    util::throw( ::E_SIG_INTERRUPT, util::text( 'Error: ‘[_1]’ interrupted by signal [_2] ‘[_3]’.', $command, $rc, $sig_names[ $rc ] ) );
                }
                if ( $rc == 127 )
                {
                    util::throw( ::E_EXECUTE_FAIL, util::text( 'Error: Failed to execute ‘[_1]’.', $command ) .
                                                   util::text( 'Command not found.' )
                    );
                }
                elsif ( $rc == 126 )
                {
                    util::throw( ::E_EXECUTE_FAIL, util::text( 'Error: Command ‘[_1]’ not executable.', $command ) );
                }
            }
        }

        dbg::leave();
        return $rc;
    }

    # Execute external command.
    # rc => -1: Throw if command returns non-zero
    # rc =>  0: Throw on failure to execute
    # rc =>  1: Return the command's return code (default)
    # out => -1: Output pass through
    # out =>  0: Ignore the command's output (default)
    # out =>  1: Return the command's output
    sub execute( $;@ )
    {
        dbg::enter();
        my $command = shift @_;
        my %options = ( rc => 1, out => 0, @_ );
        my $output = '';

        if ( $options{ out } >= 0 )
        {
            $output = `$command 2>&1`;
            chomp( $output );
            dbg::msg( "$output" );
        }
        else
        {
            system( "$command" );
        }

        my $rc = check_rc( $?, $command );

        if ( ( $options{ rc } == -1 ) && ( $rc != 0 ) )
        {
            util::throw( ::E_UNEXPECTED, util::text( 'Error: Failed to execute ‘[_1]’.', caller(0) ) .
                                         util::text( '‘[_1]’ returned ‘[_2]’:', $command, $rc ) .
                                         $output . "\n" );
        }

        dbg::leave();

        if ( ( $options{ rc } == 1 ) && ( $options{ out } == 1 ) )
        {
            return ( $rc, $output );
        }
        elsif ( $options{ out } == 1 )
        {
            return $output;
        }
        else
        {
            return $rc;
        }
    }

    # This function quotes its arguments
    sub qtd( @ )
    {
        dbg::enter();
        my @new;

        foreach ( @_ )
        {
            my $need_quotes = m/[ '&\*<>\[\]|\(\);\a\f\n\r\t\v]/;

            s/([\\`"\$])/\\$1/g;

            if ( $need_quotes )
            {
                $_ = '"' . $_ . '"';
            }

            push( @new, $_ );
        }

        dbg::leave();
        return @new;
    }

    # Pull subcommand from @ARGV.
    # When called from the top level, checks existence of worker
    # class by that name, and returns an instance of that class.
    # When called from a worker class, checks existence of a run_*
    # subroutine of that name, and returns that subroutine name.
    sub subcommand()
    {
        dbg::enter();
        my $subcommand = shift( @ARGV );
        my $caller = caller(0);
        my $help_hint;
        my $command;
        my $package;
        my $rc;

        if ( $caller eq 'gim' )
        {
            $help_hint = '';
            $command = $caller;
            $package = $subcommand;
        }
        else
        {
            $help_hint = ' ' . $caller;
            $command = 'gim ' . $caller;
            $package = $caller . '::' . $subcommand;
        }

        if ( ! defined( $subcommand ) )
        {
            util::throw( ::E_SUB_MISSING, util::text( 'Error: No subcommand given to ‘[_1]’.', $command ) );
        }

        if ( $package->isa( 'worker' ) && $package ne 'worker' )
        {
            $rc = $package->new();
        }
        else
        {
            util::throw( ::E_SUB_UNKNOWN, util::text( 'Error: Unknown subcommand ‘[_1]’.', $subcommand ) );
        }

        dbg::leave();
        return $rc;
    }

    # Given a basic message and a list of arguments, this function:
    # 1) inserts arguments in place of placeholders '[_1]', '[_2]'
    #    etc. in the basic message;
    # 2) If input message started with "Error:" or "Warning:", will
    #    color output message up to the first ":" with _ERROR_COL /
    #    _WARN_COL.
    sub text( $;@ )
    {
        dbg::enter();
        my $text = $_[0];

        # Replace '[_n]' with argument #n.
        for ( my $i = 1; $i < @_; ++$i )
        {
            $text =~ s/\[_$i\]/$_[ $i ]/;
        }

        if ( $_[0] =~ m/^Error:/ )
        {
            $text =~ s/^/$_ERROR_COL/;
            $text =~ s/:/:$_RESET/;
        }

        if ( $_[0] =~ m/^Warning:/ )
        {
            $text =~ s/^/$_WARN_COL/;
            $text =~ s/:/:$_RESET/;
        }

        dbg::leave();
        return $text . "\n";
    }

    # Throw Gim two-element exception: $0 as the error code, $1 as
    # the exception message.
    sub throw( @ )
    {
        my $msg = ( '<' x $dbg::_indent );
        $dbg::_indent = 0;
        $! = $_[0];
        die( $_[1] );
    }
}

###################################################################
###################################################################
# Similar to util::execute(), which provides combined stdout and
# stderr of a command in scalar return values, this class gives
# access to stdout of a command line by line.
#
# $self->{ out } is a stream handle on stdout.
# $self->{ err } is a stream handle on stderr.
# $self->{ errors } will receive a dump of $self->{ err } when
# $self->close() is called.
package executor
{
    # Requires the command to be executed as parameter.
    sub new( $ )
    {
        dbg::enter();
        use IPC::Open3;
        my $class = shift( @_ );
        my $self = {};
        $self->{ command } = shift( @_ );
        bless( $self, $class );

        use Symbol 'gensym';
        $self->{ err } = gensym;
        eval { $self->{ pid } = open3( $self->{ in }, $self->{ out }, $self->{ err }, $self->{ command } ); };

        if ( $@ )
        {
            dbg::msg( 'Exception thrown by open3()' );
            dbg::msg( $@ );
            $self->{ pid } = 0;
            util::throw( ::E_EXECUTE_FAIL, util::text( 'Error: Failed to execute ‘[_1]’.', $self->{ command } ) . $! . "\n" );
        }

        $self->{ 'linecount' } = 0;

        dbg::leave();
        return $self;
    }

    # Writes a line of output to $_.
    sub readline()
    {
        dbg::enter();
        my $self = shift( @_ );
        my $fh = $self->{ out };

        if ( defined( $_ = <$fh> ) )
        {
            ++$self->{ 'linecount' };
        }

        dbg::leave();
        return $_;
    }

    # Closes the stream, writing stderr to $self->{ errors }.
    # This is optional, as the destructor will do it anyway.
    sub close()
    {
        dbg::enter();
        my $self = shift( @_ );

        if ( $self->{ pid } ne 0 )
        {
            my $fh = $self->{ err };
            $self->{ errors } = do { local $/; <$fh> };

            if ( length( $self->{ errors } ) > 0 )
            {
                dbg::msg( "Output on stderr: $self->{ errors }" );
            }

            dbg::msg( "waiting for $self->{ pid }" );
            waitpid( $self->{ pid }, 0 );
            $self->{ pid } = 0;
            $self->{ rc } = util::check_rc( $?, $self->{ command } );
        }

        dbg::leave();
    }

    sub DESTROY
    {
        dbg::enter();
        my $self = shift;
        $self->close();
        dbg::leave();
    }
}

###################################################################
###################################################################
# Base class for all subcommands.
package worker
{
    sub new()
    {
        dbg::enter();
        my $class = shift( @_ );
        my $self = {};
        bless( $self, $class );
        dbg::leave();
        return $self;
    }
}

###################################################################
# 'devel' covers everything for internal Gim development. None of
# this should ever be needed by the casual Gim user.
package devel
{
    our @ISA = 'worker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        util::check_argv( 1, 1 );
        my $subcommand = util::subcommand();
        $subcommand->run();
        dbg::leave();
        return ::E_OK;
    }

    # 'devel qtd' runs a couple of tests on util::qtd.
    package devel::qtd
    {
        our @ISA = 'devel';

        sub run()
        {
            dbg::enter();
            my $self = shift( @_ );

            my %tests = ( 'foo bar' => '"foo bar"',
                          'foo$bar' => "foo\$bar",
                          'foo&bar' => '"foo&bar"',   # FIXME
                          'foo*bar' => '"foo*bar"',
                          'foo<bar' => '"foo<bar"',
                          'foo`bar' => '"foo\`bar"',  #FIXME
                          'foo"bar' => '"foo\"bar"',  #FIXME
                          'foo[bar' => '"foo[bar"',
                          'foo|bar' => '"foo|bar"',
                          'foo(bar' => '"foo(bar"',
                          'foo;bar' => '"foo;bar"',
                          'foo\bar' => '"foo\\bar"',  # FIXME
                          'foo	bar' => '"foo	bar"',
                        );

            my @quoted = util::qtd( keys %tests );

            while ( my ( $expected, $input ) = sort each %tests )
            {
                my $observed = shift( @quoted );

                printf( "%10s -> %10s ... ", $input, $expected );

                if ( $observed eq $expected )
                {
                    printf( "%s%s%s\n", $_OK_COL, "OK", $_RESET );
                }
                else
                {
                    printf( "%s%s%s (got: %s)\n", $_ERROR_COL, "ERR", $_RESET, $observed );
                }
            }

            dbg::leave();
        }
    }

    # 'devel test' runs a list of regression tests.
    package devel::test
    {
        our @ISA = 'devel';

        sub run()
        {
            dbg::enter();
            my $self = shift( @_ );
            util::check_argv( -1, 0 );
            my ( $rc, $output );

            # preparing test executable
            ( my $testexe = q{#!/usr/bin/env bash

            o=1
            e=1

            for arg in "$@"
            do
                case $arg in
                    o)
                        echo "stdout$o"
                        o=$(($o + 1))
                        ;;
                    e)
                        echo "stderr$e" >&2
                        e=$(($e + 1))
                        ;;
                    [0-9])
                        exit $arg
                        ;;
                    s)
                        kill -s SIGINT $$
                        ;;
                esac
            done
            }) =~ s/^ {8}//mg;
            open( my $fh, '>', 'testexe' ) || die( "Error: Could not open 'testexe' for writing.\n" . $! );
            print( $fh $testexe );
            close( $fh );
            chmod( 0755, 'testexe' );
            print( "Running self-tests:\n" );

            # util::execute()
            my $expected = "stdout1\nstdout2\nstdout3\nstderr1\nstdout4\nstdout5\nstdout6";
            eval { util::execute( 'nosuchcommand' ); }; die unless ( $@ =~ /.*Error:.* Failed to execute ‘nosuchcommand’\.\nCommand not found\./ );
            $rc = util::execute( './testexe o o o e o o o 0' ); die unless ( $rc == 0 );
            $rc = util::execute( './testexe o o o e o o o 1' ); die unless ( $rc == 1 );
            eval { util::execute( './testexe o o o e o o o s' ); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );
            $rc = util::execute( './testexe o o o e o o o 0', rc => 0 ); die unless ( $rc == 0 );
            $rc = util::execute( './testexe o o o e o o o 1', rc => 0 ); die unless ( $rc == 1 );
            eval { util::execute( './testexe o o o e o o o s', rc => 0 ); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );
            $rc = util::execute( './testexe o o o e o o o 0', rc => -1 ); die unless ( $rc == 0 );
            eval { util::execute( './testexe o o o e o o o 1', rc => -1 ); }; die unless ( $@ =~ /.*Error:.* Failed to execute ‘devel’\.\n.*‘\.\/testexe o o o e o o o 1’ returned ‘1’:\n$expected/ );
            eval { util::execute( './testexe o o o e o o o s', rc => -1 ); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );
            ( $rc, $output ) = util::execute( './testexe 0', out => 1 ); die unless ( ( $rc == 0 ) && ( $output eq '' ) );
            ( $rc, $output ) = util::execute( './testexe 1', out => 1 ); die unless ( ( $rc == 1 ) && ( $output eq '' ) );
            ( $rc, $output ) = util::execute( './testexe o o o e o o o 0', out => 1 ); die unless ( $rc == 0 && $output eq $expected );
            ( $rc, $output ) = util::execute( './testexe o o o e o o o 1', out => 1 ); die unless ( $rc == 1 && $output eq $expected );
            eval { util::execute( './testexe o o o e o o o s', out => 1 ); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );

            # executor
            my $exe;
            eval { $exe = new executor( 'nosuchcommand' ); }; die unless ( $@ =~ /.*Error:.* Failed to execute ‘nosuchcommand’\./ );
            $exe = new executor( './testexe o o o e o o o 0' );
            $rc = 1;
            while ( $exe->readline() )
            {
                chomp;
                die unless ( $_ eq "stdout$rc" );
                ++$rc;
            }
            $exe->close();
            die unless ( $exe->{ linecount } == 6 );
            die unless ( $exe->{ errors } eq "stderr1\n" );
            die unless ( $exe->{ rc } == 0 );
            $exe = new executor( './testexe o o o e o o o 1' ); $exe->close(); die unless ( $exe->{ rc } == 1 );
            $exe = new executor( './testexe o o o e o o o s' ); eval { $exe->close(); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );

            # util::subcommand()
            ( util::execute( "$0" ) == ::E_SUB_MISSING ) || die;
            ( util::execute( "$0 foo" ) == ::E_SUB_UNKNOWN ) || die;
            ( util::execute( "$0 worker" ) == ::E_SUB_UNKNOWN ) || die;
            ( util::execute( "$0 devel" ) == ::E_SUB_MISSING ) || die;

            # check_argv()
            @ARGV = (); util::check_argv( -1, -1 );
            @ARGV = (); util::check_argv( 0, 0 );
            @ARGV = ( 1 ); util::check_argv( -1, 1 );
            @ARGV = ( 1 ); util::check_argv( 0, 1 );
            @ARGV = ( 1 ); util::check_argv( 1, 1 );
            @ARGV = ( 1 ); util::check_argv( 1, 2 );
            @ARGV = ( 1 ); eval { util::check_argv( 0, 0 ); }; if ( $@ ) { die unless $@ =~ /.*Error:.* Too many arguments./; }
            @ARGV = ( ); eval { util::check_argv( 1, 1 ); }; if ( $@ ) { die unless $@ =~ /.*Error:.* Too few arguments./; }
            @ARGV = ( 1, 2 ); eval { util::check_argv( 1, 1 ); }; if ( $@ ) { die unless $@ =~ /.*Error:.* Too many arguments./; }
            @ARGV = ( 1, 2 ); eval { util::check_argv( 2, 2 ); }; if ( $@ ) { die unless $@ =~ /.*Error:.* Too few arguments./; }

            # Clean up
            unlink( 'testexe' );
            print( "Done.\n" );
            dbg::leave();
        }
    }
}

###################################################################
###################################################################
package gim;

print( $_RESET );
my $command;
Getopt::Long::GetOptions(
    'debug:s' => \&dbg::init
);

$command = util::subcommand() unless ( $command );
$command->run();
