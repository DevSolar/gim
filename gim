#!/usr/bin/perl

use strict;
use warnings;
use utf8;
use open( ':std', ':encoding(UTF-8)' );

use Getopt::Long     qw( :config posix_default permute pass_through );
use Text::Wrap;

###################################################################
###################################################################
# Exit Codes
use constant E_OK            =>  0;
use constant E_SUB_MISSING   =>  1;  # No subcommand given
use constant E_SUB_UNKNOWN   =>  2;  # Subcommand unknown
use constant E_EXECUTE_FAIL  =>  3;  # Execution failure
use constant E_SIG_INTERRUPT =>  4;  # Interrupted by signal
use constant E_UNEXPECTED    =>  5;  # Unexpected backend error
use constant E_ARGUMENTS     =>  6;  # Wrong number of arguments
use constant E_NOTFILE       =>  7;  # Not a regular file
use constant E_NOTFILEORDIR  =>  8;  # Not a regular file or directory
use constant E_NOTTRACKED    =>  9;  # Not a file under version control
use constant E_INTERNAL      => 10;  # Internal error

###################################################################
# Colors

# Default is 'no color'
my $_COLOR   = 'never';
my $_RED     = '';
my $_GREEN   = '';
my $_BLUE    = '';
my $_YELLOW  = '';
my $_MAGENTA = '';
my $_CYAN    = '';
my $_RESET   = '';

if ( -t STDOUT )
{
    # If we are printing to terminal, *do* use colors.
    use Term::ANSIColor  qw( :constants );
    $_COLOR   = 'always';
    $_RED     = ::RED;
    $_GREEN   = ::GREEN;
    $_BLUE    = ::BLUE;
    $_YELLOW  = ::YELLOW;
    $_MAGENTA = ::MAGENTA;
    $_CYAN    = ::CYAN;
    $_RESET   = ::RESET;
}

# Color Scheme
my $_OK_COL       = $_GREEN;
my $_ERROR_COL    = $_RED;
my $_WARN_COL     = $_YELLOW;

###################################################################
# Globals
my %_category =  # Command categories
(
    'info'    => { sortorder => 0, about => 'Obtaining information' },
    'local'   => { sortorder => 1, about => 'Act on your local repository' },
    'remote'  => { sortorder => 2, about => 'Act on a remote repository' }
);
my %_help;       # Help on [command] => category, about, usage, help
my %_topic;      # Help on [topic] => sortorder, about, help

###################################################################
# Reusable Regexes
{
    no warnings qw( qw );
    use constant RE_QUOTED_STRING => qw( '((?:\\\\?.)*?)' );
    use constant RE_COMMENT => qw( (\\s*(?:#.*)?) );
}

###################################################################
###################################################################
# 'dbg' provides call stack trace / log message functionality.
# With 'gim ... --debug', trace log is written to terminal. With
# 'gim ... --debug <filename>', trace log is written to file.
# Note that '--debug [<filename>]' needs to be at the end of the
# command line due to the way argument parsing works.
package dbg
{
    my $_dbg;
    our $_indent = 0;
    # NOT setting these with the other colors at the top of the
    # script, as debug coloring depends on whether *debug* goes to
    # terminal or file, not the general output.
    my $_dbg_color = ::MAGENTA;
    my $_dbg_clear = ::CLEAR;

    # Called from main's GetOptions, with an optional log filename
    # as second argument. (First argument of the function is always
    # 'debug'.) Initializes the debug file handle $_dbg.
    sub init( $;$ )
    {
        if ( length( $_[1] ) )
        {
            # Logging to file
            if ( ! open( $_dbg, '>', $_[1] ) )
            {
                $_dbg = util::pager();
                print( $_dbg util::text( 'Warning: Could not open debug output file ‘[_1]’.', $_[1] ) );
            }
            else
            {
                $_dbg_color = '';
                $_dbg_clear = '';
            }
        }
        else
        {
            $_dbg = util::pager();

            if ( ! -t STDOUT )
            {
                $_dbg_color = '';
                $_dbg_clear = '';
            }
        }
    }

    # Called upon subroutine entry. Prints stack trace entry and
    # increases indentation of subsequent entries.
    sub enter()
    {
        if ( defined( $_dbg ) )
        {
            package DB;
            print( $_dbg ( ' ' x $_indent ) . $_dbg_color . '>> ' . (caller(1))[3] . '(' );

            if ( (caller(1))[4] )
            {
                print( $_dbg ' ' . join( ', ', map { defined ? qq("$_") : '<undef>' } @DB::args ) . ' ' );
            }

            print( $_dbg ")$_dbg_clear\n" );
            $_indent += 3;
        }
    }

    # Print a log entry at current indentation.
    sub msg( $ )
    {
        if ( defined( $_dbg ) )
        {
            for ( split( "\n", $_[0] ) )
            {
                print( $_dbg ( ' ' x $_indent ) . $_dbg_color . $_ . $_dbg_clear . "\n" );
            }
        }
    }

    # Called before subroutine exit. Prints stack trace entry and
    # decreases indentation of subsequent entries.
    sub leave()
    {
        if ( defined( $_dbg ) )
        {
            $_indent -= 3;
            print( $_dbg ( ' ' x $_indent ) . $_dbg_color . '<< ' . (caller(1))[3] . $_dbg_clear . "\n" );
        }
    }

    # Close the debug file handle before exit.
    END
    {
        if ( defined( $_dbg ) && fileno( $_dbg ) )
        {
            dbg::msg( 'dbg::END' );
            close( $_dbg );
        }
    }
}

###################################################################
###################################################################
# 'util' covers any utility subroutines.
package util
{
    # Check that the number of arguments (remaining @ARGV) is no
    # less than the first and no more than the second argument.
    # -1 means 'no check'.
    sub check_argv( $$ )
    {
        dbg::enter();

        if ( @ARGV < $_[0] )
        {
            util::throw( ::E_ARGUMENTS, util::text( 'Error: Too few arguments.' ) .
                                        util::text( 'Try ‘[_1]’.', 'gim help ' . caller(0) ) );
        }

        if ( ( $_[1] > -1 ) && ( @ARGV > $_[1] ) )
        {
            util::throw( ::E_ARGUMENTS, util::text( 'Error: Too many arguments.' ) .
                                        util::text( 'Try ‘[_1]’.', 'gim help ' . caller(0) ) );
        }

        dbg::leave();
    }

    # Throws if one of the arguments does not refer to a file.
    # Generates warnings for symbolic links, which are not portable
    # across platforms.
    sub check_files( @ )
    {
        dbg::enter();
        my $pager = util::pager();

        foreach ( @_ )
        {
            dbg::msg( "checking ‘$_’" );

            if ( ! -f $_ )
            {
                util::throw( ::E_NOTFILE, util::text( 'Error: ‘[_1]’ is not a regular file.', $_ ) );
            }

            if ( -l $_ )
            {
                print( $pager util::text( 'Warning: ‘[_1]’ is a symbolic link, which is not portable.', $_ ) );
            }
        }

        dbg::leave();
    }

    # Check that the list of arguments violates a predicate given
    # as first parameter. Returns if all arguments check out,
    # throws otherwise. Generates warnings for symbolic links,
    # which are not portable across platforms.
    # Predicates:
    # ::E_NOTFILE      -- if item is regular file
    # ::E_NOTFILEORDIR -- if item is regular file or directory
    # ::E_NOTTRACKED   -- if item is not under version control
    sub check_filespecs( $@ )
    {
        dbg::enter();
        my $pager = util::pager();
        my $func = shift( @_ );

        foreach ( @_ )
        {
            my $filespec = $_;
            dbg::msg( "checking ‘$filespec’" );

            use feature qw( switch );
            no warnings qw( experimental::smartmatch );

            given ( $func )
            {
                when ( ::E_NOTFILE )
                {
                    if ( ! -f $filespec )
                    {
                        util::throw( ::E_NOTFILE, util::text( 'Error: ‘[_1]’ is not a regular file.', $filespec ) );
                    }
                }
                when ( ::E_NOTFILEORDIR )
                {
                    if ( ! -f $filespec && ! -d $filespec )
                    {
                        util::throw( ::E_NOTFILEORDIR, util::text( 'Error: ‘[_1]’ is neither regular file nor directory.', $filespec ) );
                    }
                }
                when ( ::E_NOTTRACKED )
                {
                    if ( util::execute( "git ls-files --error-unmatch $filespec" ) )
                    {
                        util::throw( ::E_NOTTRACKED, util::text( 'Error: ‘[_1]’ is not under version control.', $filespec ) );
                    }
                }
                default
                {
                    util::throw( ::E_INTERNAL, 'Error: Unknown predicate in check_filespecs().' )
                }
            }

            if ( -l $filespec )
            {
                print( $pager util::text( 'Warning: ‘[_1]’ is a symbolic link, which is not portable.', $filespec ) );
            }
        }

        dbg::leave();
    }

    # Check return code from external calls
    sub check_rc( $$ )
    {
        dbg::enter();
        my ( $rc, $command ) = @_;

        # Mapping of signal numbers to signal names for error messages
        use Config '%Config';
        my @sig_names;
        @sig_names[ split( ' ', $Config{ sig_num } ) ] = split( ' ', $Config{ sig_name } );

        if ( $rc != 0 )
        {
            if ( $rc == -1 )
            {
                util::throw( ::E_EXECUTE_FAIL, util::text( 'Error: Failed to execute ‘[_1]’.', 'sh' ) );
            }
            elsif ( $rc & 127 )
            {
                $rc &= 127;
                util::throw( ::E_SIG_INTERRUPT, util::text( 'Error: ‘[_1]’ interrupted by signal [_2] ‘[_3]’.', $command, $rc, $sig_names[ $rc ] ) );
            }
            else
            {
                $rc = $rc >> 8;

                if ( $rc > 128 )
                {
                    $rc -= 128;
                    util::throw( ::E_SIG_INTERRUPT, util::text( 'Error: ‘[_1]’ interrupted by signal [_2] ‘[_3]’.', $command, $rc, $sig_names[ $rc ] ) );
                }
                if ( $rc == 127 )
                {
                    util::throw( ::E_EXECUTE_FAIL, util::text( 'Error: Failed to execute ‘[_1]’.', $command ) .
                                                   util::text( 'Command not found.' )
                    );
                }
                elsif ( $rc == 126 )
                {
                    util::throw( ::E_EXECUTE_FAIL, util::text( 'Error: Command ‘[_1]’ not executable.', $command ) );
                }
            }
        }

        dbg::leave();
        return $rc;
    }

    # Execute external command.
    # rc => -1: Throw if command returns non-zero
    # rc =>  0: Throw on failure to execute
    # rc =>  1: Return the command's return code (default)
    # out => -1: Output pass through
    # out =>  0: Ignore the command's output (default)
    # out =>  1: Return the command's output
    sub execute( $;@ )
    {
        dbg::enter();
        my $command = shift @_;
        my %options = ( rc => 1, out => 0, @_ );
        my $output = '';

        if ( $options{ out } >= 0 )
        {
            $output = `$command 2>&1`;
            chomp( $output );
            dbg::msg( "$output" );
        }
        else
        {
            system( "$command" );
        }

        my $rc = check_rc( $?, $command );

        if ( ( $options{ rc } == -1 ) && ( $rc != 0 ) )
        {
            util::throw( ::E_UNEXPECTED, util::text( 'Error: Failed to execute ‘[_1]’.', caller(0) ) .
                                         util::text( '‘[_1]’ returned ‘[_2]’:', $command, $rc ) .
                                         $output . "\n" );
        }

        dbg::leave();

        if ( ( $options{ rc } == 1 ) && ( $options{ out } == 1 ) )
        {
            return ( $rc, $output );
        }
        elsif ( $options{ out } == 1 )
        {
            return $output;
        }
        else
        {
            return $rc;
        }
    }

    my $_pager;

    # Acquire a handle to the output pager process. There will be
    # only one pager process, even if this subroutine is called
    # multiple times.
    # If output is not to a terminal (e.g. redirected into a file)
    # then the pager will be 'cat' (i.e., pass-through).
    # If the environment variable GIM_PAGER is set, that will be
    # the pager used.
    # The default pager is 'less'. If the LESS environment variable
    # is set, it will be used; else the '-FeRS' options will be set.
    # Note that Git's core.pager is NOT honored.
    sub pager()
    {
        dbg::enter();

        if ( ! defined( $_pager ) )
        {
            my $cmd;
            $Text::Wrap::columns = ( `tput cols` || 76 ) - 2;

            if ( -t STDOUT )
            {
                if ( exists( $ENV{ GIM_PAGER } ) )
                {
                    $cmd = $ENV{ GIM_PAGER };
                }
                else
                {
                    if ( exists( $ENV{ LESS } ) )
                    {
                        $cmd = 'less';
                    }
                    else
                    {
                        $cmd = 'less -FeRS';
                    }
                }
            }
            else
            {
                $cmd = 'cat';
            }

            if ( ! open( $_pager, "| $cmd" ) )
            {
                util::throw( ::E_EXECUTE_FAIL, util::text( 'Error: Failed to execute ‘[_1]’.', $cmd ) );
            }
        }

        dbg::leave();
        return $_pager;
    }

    # This function quotes its arguments
    sub qtd( @ )
    {
        dbg::enter();
        my @new;

        foreach ( @_ )
        {
            my $need_quotes = m/[ '&\*<>\[\]|\(\);\a\f\n\r\t\v]/;

            s/([\\`"\$])/\\$1/g;

            if ( $need_quotes )
            {
                $_ = '"' . $_ . '"';
            }

            push( @new, $_ );
        }

        dbg::leave();
        return @new;
    }

    sub separator()
    {
        return ( '-' x $Text::Wrap::columns ) . "\n";
    }

    # Pull subcommand from @ARGV.
    # When called from the top level, checks existence of worker
    # class by that name, and returns an instance of that class.
    # When called from a worker class, checks existence of a run_*
    # subroutine of that name, and returns that subroutine name.
    sub subcommand()
    {
        dbg::enter();
        my $subcommand = shift( @ARGV );
        my $caller = caller(0);
        my $help_hint;
        my $command;
        my $package;
        my $rc;

        if ( $caller eq 'gim' )
        {
            $help_hint = '';
            $command = $caller;
            $package = $subcommand;
        }
        else
        {
            $help_hint = ' ' . $caller;
            $command = 'gim ' . $caller;
            $package = $caller . '::' . $subcommand;
        }

        if ( ! defined( $subcommand ) )
        {
            util::throw( ::E_SUB_MISSING, util::text( 'Error: No subcommand given to ‘[_1]’.', $command ) );
        }

        if ( $package->isa( 'worker' ) && $package ne 'worker' )
        {
            $rc = $package->new();
        }
        else
        {
            util::throw( ::E_SUB_UNKNOWN, util::text( 'Error: Unknown subcommand ‘[_1]’.', $subcommand ) );
        }

        dbg::leave();
        return $rc;
    }

    # Given a basic message and a list of arguments, this function:
    # 1) inserts arguments in place of placeholders '[_1]', '[_2]'
    #    etc. in the basic message;
    # 2) If input message started with "Error:" or "Warning:", will
    #    color output message up to the first ":" with _ERROR_COL /
    #    _WARN_COL.
    sub text( $;@ )
    {
        dbg::enter();
        my $text = $_[0];

        # Replace '[_n]' with argument #n.
        for ( my $i = 1; $i < @_; ++$i )
        {
            $text =~ s/\[_$i\]/$_[ $i ]/;
        }

        if ( $_[0] =~ m/^Error:/ )
        {
            $text =~ s/^/$_ERROR_COL/;
            $text =~ s/:/:$_RESET/;
        }

        if ( $_[0] =~ m/^Warning:/ )
        {
            $text =~ s/^/$_WARN_COL/;
            $text =~ s/:/:$_RESET/;
        }

        dbg::leave();
        return $text . "\n";
    }

    # Throw Gim two-element exception: $0 as the error code, $1 as
    # the exception message.
    sub throw( @ )
    {
        my $msg = ( '<' x $dbg::_indent );
        $dbg::_indent = 0;
        $! = $_[0];
        die( $_[1] );
    }

    END
    {
        dbg::msg( 'util::END' );

        if ( defined( $_pager ) )
        {
            close( $_pager );
        }
    }
}

###################################################################
###################################################################
# Similar to util::execute(), which provides combined stdout and
# stderr of a command in scalar return values, this class gives
# access to stdout of a command line by line.
#
# $self->{ out } is a stream handle on stdout.
# $self->{ err } is a stream handle on stderr.
# $self->{ errors } will receive a dump of $self->{ err } when
# $self->close() is called.
package executor
{
    # Requires the command to be executed as parameter.
    sub new( $ )
    {
        dbg::enter();
        use IPC::Open3;
        my $class = shift( @_ );
        my $self = {};
        $self->{ command } = shift( @_ );
        bless( $self, $class );

        use Symbol 'gensym';
        $self->{ err } = gensym;
        eval { $self->{ pid } = open3( $self->{ in }, $self->{ out }, $self->{ err }, $self->{ command } ); };

        if ( $@ )
        {
            dbg::msg( 'Exception thrown by open3()' );
            dbg::msg( $@ );
            $self->{ pid } = 0;
            util::throw( ::E_EXECUTE_FAIL, util::text( 'Error: Failed to execute ‘[_1]’.', $self->{ command } ) . $! . "\n" );
        }

        util::pager()->autoflush( 1 );
        $self->{ 'linecount' } = 0;

        dbg::leave();
        return $self;
    }

    # Writes a line of output to $_.
    sub readline()
    {
        dbg::enter();
        my $self = shift( @_ );
        my $fh = $self->{ out };

        if ( defined( $_ = <$fh> ) )
        {
            ++$self->{ 'linecount' };
        }

        dbg::leave();
        return $_;
    }

    # Closes the stream, writing stderr to $self->{ errors }.
    # This is optional, as the destructor will do it anyway.
    sub close()
    {
        dbg::enter();
        my $self = shift( @_ );

        if ( $self->{ pid } ne 0 )
        {
            my $fh = $self->{ err };
            $self->{ errors } = do { local $/; <$fh> };

            if ( length( $self->{ errors } ) > 0 )
            {
                dbg::msg( "Output on stderr: $self->{ errors }" );
            }

            dbg::msg( "waiting for $self->{ pid }" );
            waitpid( $self->{ pid }, 0 );
            $self->{ pid } = 0;
            $self->{ rc } = util::check_rc( $?, $self->{ command } );
        }

        dbg::leave();
    }

    sub DESTROY
    {
        dbg::enter();
        my $self = shift;
        $self->close();
        dbg::leave();
    }
}

###################################################################
###################################################################
# Base class for all subcommands.
package worker
{
    sub new()
    {
        dbg::enter();
        my $class = shift( @_ );
        my $self = {};
        bless( $self, $class );
        dbg::leave();
        return $self;
    }
}

###################################################################
# 'devel' covers everything for internal Gim development. None of
# this should ever be needed by the casual Gim user.
package devel
{
    our @ISA = 'worker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        util::check_argv( 1, 1 );
        my $subcommand = util::subcommand();
        $subcommand->run();
        dbg::leave();
        return ::E_OK;
    }

    # 'devel qtd' runs a couple of tests on util::qtd.
    package devel::qtd
    {
        our @ISA = 'devel';

        sub run()
        {
            dbg::enter();
            my $self = shift( @_ );

            my %tests = ( 'foo bar' => '"foo bar"',
                          'foo$bar' => "foo\$bar",
                          'foo&bar' => '"foo&bar"',   # FIXME
                          'foo*bar' => '"foo*bar"',
                          'foo<bar' => '"foo<bar"',
                          'foo`bar' => '"foo\`bar"',  #FIXME
                          'foo"bar' => '"foo\"bar"',  #FIXME
                          'foo[bar' => '"foo[bar"',
                          'foo|bar' => '"foo|bar"',
                          'foo(bar' => '"foo(bar"',
                          'foo;bar' => '"foo;bar"',
                          'foo\bar' => '"foo\\bar"',  # FIXME
                          'foo	bar' => '"foo	bar"',
                        );

            my @quoted = util::qtd( keys %tests );

            while ( my ( $expected, $input ) = sort each %tests )
            {
                my $observed = shift( @quoted );

                printf( "%10s -> %10s ... ", $input, $expected );

                if ( $observed eq $expected )
                {
                    printf( "%s%s%s\n", $_OK_COL, "OK", $_RESET );
                }
                else
                {
                    printf( "%s%s%s (got: %s)\n", $_ERROR_COL, "ERR", $_RESET, $observed );
                }
            }

            dbg::leave();
        }
    }

    # 'devel test' runs a list of regression tests.
    package devel::test
    {
        our @ISA = 'devel';

        sub run()
        {
            dbg::enter();
            my $self = shift( @_ );
            my $pager = util::pager();
            my ( $rc, $output );

            # preparing test executable
            ( my $testexe = q{#!/usr/bin/env bash

            o=1
            e=1

            for arg in "$@"
            do
                case $arg in
                    o)
                        echo "stdout$o"
                        o=$(($o + 1))
                        ;;
                    e)
                        echo "stderr$e" >&2
                        e=$(($e + 1))
                        ;;
                    [0-9])
                        exit $arg
                        ;;
                    s)
                        kill -s SIGINT $$
                        ;;
                esac
            done
            }) =~ s/^ {8}//mg;
            open( my $fh, '>', 'testexe' ) || die( "Error: Could not open 'testexe' for writing.\n" . $! );
            print( $fh $testexe );
            close( $fh );
            chmod( 0755, 'testexe' );
            print( $pager "Running self-tests:\n" );

            # util::execute()
            my $expected = "stdout1\nstdout2\nstdout3\nstderr1\nstdout4\nstdout5\nstdout6";
            eval { util::execute( 'nosuchcommand' ); }; die unless ( $@ =~ /.*Error:.* Failed to execute ‘nosuchcommand’\.\nCommand not found\./ );
            $rc = util::execute( './testexe o o o e o o o 0' ); die unless ( $rc == 0 );
            $rc = util::execute( './testexe o o o e o o o 1' ); die unless ( $rc == 1 );
            eval { util::execute( './testexe o o o e o o o s' ); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );
            $rc = util::execute( './testexe o o o e o o o 0', rc => 0 ); die unless ( $rc == 0 );
            $rc = util::execute( './testexe o o o e o o o 1', rc => 0 ); die unless ( $rc == 1 );
            eval { util::execute( './testexe o o o e o o o s', rc => 0 ); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );
            $rc = util::execute( './testexe o o o e o o o 0', rc => -1 ); die unless ( $rc == 0 );
            eval { util::execute( './testexe o o o e o o o 1', rc => -1 ); }; die unless ( $@ =~ /.*Error:.* Failed to execute ‘devel’\.\n.*‘\.\/testexe o o o e o o o 1’ returned ‘1’:\n$expected/ );
            eval { util::execute( './testexe o o o e o o o s', rc => -1 ); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );
            ( $rc, $output ) = util::execute( './testexe 0', out => 1 ); die unless ( ( $rc == 0 ) && ( $output eq '' ) );
            ( $rc, $output ) = util::execute( './testexe 1', out => 1 ); die unless ( ( $rc == 1 ) && ( $output eq '' ) );
            ( $rc, $output ) = util::execute( './testexe o o o e o o o 0', out => 1 ); die unless ( $rc == 0 && $output eq $expected );
            ( $rc, $output ) = util::execute( './testexe o o o e o o o 1', out => 1 ); die unless ( $rc == 1 && $output eq $expected );
            eval { util::execute( './testexe o o o e o o o s', out => 1 ); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );

            # executor
            my $exe;
            eval { $exe = new executor( 'nosuchcommand' ); }; die unless ( $@ =~ /.*Error:.* Failed to execute ‘nosuchcommand’\./ );
            $exe = new executor( './testexe o o o e o o o 0' );
            $rc = 1;
            while ( $exe->readline() )
            {
                chomp;
                die unless ( $_ eq "stdout$rc" );
                ++$rc;
            }
            $exe->close();
            die unless ( $exe->{ linecount } == 6 );
            die unless ( $exe->{ errors } eq "stderr1\n" );
            die unless ( $exe->{ rc } == 0 );
            $exe = new executor( './testexe o o o e o o o 1' ); $exe->close(); die unless ( $exe->{ rc } == 1 );
            $exe = new executor( './testexe o o o e o o o s' ); eval { $exe->close(); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );

            # util::subcommand()
            ( util::execute( "$0" ) == ::E_SUB_MISSING ) || die;
            ( util::execute( "$0 foo" ) == ::E_SUB_UNKNOWN ) || die;
            ( util::execute( "$0 worker" ) == ::E_SUB_UNKNOWN ) || die;
            ( util::execute( "$0 devel" ) == ::E_SUB_MISSING ) || die;

            # check_argv()
            @ARGV = (); util::check_argv( -1, -1 );
            @ARGV = (); util::check_argv( 0, 0 );
            @ARGV = ( 1 ); util::check_argv( -1, 1 );
            @ARGV = ( 1 ); util::check_argv( 0, 1 );
            @ARGV = ( 1 ); util::check_argv( 1, 1 );
            @ARGV = ( 1 ); util::check_argv( 1, 2 );
            @ARGV = ( 1 ); eval { util::check_argv( 0, 0 ); }; if ( $@ ) { die unless $@ =~ /.*Error:.* Too many arguments./; }
            @ARGV = ( ); eval { util::check_argv( 1, 1 ); }; if ( $@ ) { die unless $@ =~ /.*Error:.* Too few arguments./; }
            @ARGV = ( 1, 2 ); eval { util::check_argv( 1, 1 ); }; if ( $@ ) { die unless $@ =~ /.*Error:.* Too many arguments./; }
            @ARGV = ( 1, 2 ); eval { util::check_argv( 2, 2 ); }; if ( $@ ) { die unless $@ =~ /.*Error:.* Too few arguments./; }

            # Clean up
            unlink( 'testexe' );
            print( $pager "Done.\n" );
            dbg::leave();
        }
    }

$_help{ 'devel' } =
{
    category => 'local',
    about => 'Maintainer features',
    usage => q{gim devel <subcommand>
},
    help => q{Various features for maintainers of gim.

Available subcommands are:

 * qtd      --  testing function for util::qtd

 * test     --  runs a number of regression tests
}};

}

###################################################################
# 'help' covers user documentation.
package help
{
    our @ISA = 'worker';

    sub run()
    {
        dbg::enter();
        my $self = shift( @_ );
        # 'help', 'help <cmd>', 'help topic <topic>'
        util::check_argv( 0, 2 );

        if ( @ARGV == 0 )
        {
            # 'help' -- basic self-documentation
            $self->_help();
        }
        else
        {
            my $cmd = shift( @ARGV );

            if ( $cmd ne 'topic' )
            {
                # 'help <subcommand>' -- subcommand documentation
                $self->_help_cmd( $cmd );
            }
            else
            {
                # 'help topic [<topic>]' -- general documentation
                $self->_help_topic();
            }
        }

        dbg::leave();
        return ::E_OK;
    }

    # 'help' prints a summary on subcommands on which help is available.
    sub _help()
    {
        dbg::enter();
        my $self = shift( @_ );
        my $pager = util::pager();
        print( $pager '  ' . util::text( 'Usage:' ) .
                      "    gim help <subcommand>\n\n" .
                      '  ' . util::text( 'Available subcommands:' ) .
                      "\n"
        );

        # List the subcommands under each %_category in their sort order
        foreach my $category ( sort { $_category{ $a }{ sortorder } <=> $_category{ $b }{ sortorder } } keys %_category )
        {
            print( $pager '  ' . util::text( $_category{ $category }{ about } ) );

            # The subcommands under each category are sorted alphabetically
            foreach my $subcommand ( sort keys %_help )
            {
                if ( ! $_help{ $subcommand }{ category } )
                {
                    util::throw( ::E_INTERNAL, "Error: Subcommand without category: $subcommand\n" );
                }

                # Print only subcommands of the current category
                if ( $_help{ $subcommand }{ category } ne $category )
                {
                    next;
                }

                printf( $pager "    gim %-19s %s\n", $subcommand, $_help{ $subcommand }{ about } );
            }

            print( $pager "\n" );
        }

        print( $pager '  ' . util::text( 'Additional help on Gim topics:' ) .
                      '    gim help topic [<topic>]' .
                      "\n"
        );

        dbg::leave();
    }

    # 'help <subcommand>' prints the help on a specific subcommand
    sub _help_cmd( $ )
    {
        dbg::enter();
        my $self = shift( @_ );
        util::check_argv( -1, 0 );

        if ( ! defined( $_help{ $_[0] }{ help } ) )
        {
            util::throw( ::E_SUB_UNKNOWN, util::text( 'Error: Unknown subcommand ‘[_1]’.', $_[0] ) .
                                          util::text( 'Try ‘[_1]’.', 'gim help' )
            );
        }

        my $pager = util::pager();
        print( $pager '  ' . util::text( 'Usage:' ) .
                      '    ' . $_help{ $_[0] }{ usage } .
                      "\n"
        );

        print( $pager Text::Wrap::fill( '  ', '  ', $_help{ $_[0] }{ help } ) );
        dbg::leave();
    }

    # 'help topic [<topic>]' prints help on general topics.
    sub _help_topic()
    {
        dbg::enter();
        my $self = shift( @_ );

        if ( @ARGV == 0 )
        {
            # Overview on topics
            my $pager = util::pager();
            print( $pager '  ' . util::text( 'Usage:' ) .
                          "    gim help topic <topic>\n\n" .
                          '  ' . util::text( 'Available topics:' )
            );

            foreach my $topic ( sort { $_topic{ $a }{ sortorder } <=> $_topic{ $b }{ sortorder } } keys %_topic )
            {
                printf( $pager "    %-23s %s\n", $topic, $_topic{ $topic }{ about } );
            }
        }
        else
        {
            # Help on a specific topic
            my $topic = shift( @ARGV );
            util::check_argv( -1, 0 );

            if ( ! $_topic{ $topic }{ help } )
            {
                util::throw( ::E_SUB_UNKNOWN, util::text( 'Error: Unknown topic ‘[_1]’.', $topic ) .
                                              util::text( 'Try ‘[_1]’.', 'gim help topic' )
                );
            }

            my $pager = util::pager();
            print( $pager '  ' .
                          $_topic{ $topic }{ about } .
                          "\n\n" .
                          Text::Wrap::fill( '  ', '  ', $_topic{ $topic }{ help } )
            );
        }

        dbg::leave();
    }

$_help{ help } =
{
    category => 'info',
    about => 'This help summary',
    usage => q{gim [help|--help]
    gim help <subcommand>
    gim <subcommand> --help
    gim help topic <topic>
},
    help => q{Gim comes with its own help functionality. Ideally,
this is all you should ever need.

Use ‘gim help’ to get an overview of the available subcommands, and
‘gim help <subcommand>’ to get the help on a specific subcommand.

There are also general help topics available. You get a list of
these with ‘gim help topic’, and display a specific topic with ‘gim
help topic <topic>’.
}};

}

###################################################################
###################################################################
$_topic{ paging } =
{
    sortorder => 0,
    about => q{Gim Output Paging},
    help => q{Gim passes its output through a pager, so that output
stops each time the screen is filled up, waiting for you to press a
key to continue.

The default pager used is ‘less’. You can override the pager used
by setting the GIM_PAGER environment variable.

The ‘less’ utility accepts a number of options controlling its
behavior. These options can be set globally by setting the LESS
environment variable. If this variable is set, Gim respects its
setting. If LESS is not set, Gim will use ‘--quit-if-one-screen’,
‘--quit-at-eof’, ‘--RAW-CONTROL-CHARS’, and ‘--chop-long-lines’
(‘-FeRS’).
}};

###################################################################
###################################################################
package gim;

print( $_RESET );
my $command;
Getopt::Long::GetOptions(
    'debug:s' => \&dbg::init,
    'help|h' => sub { $command = help->new(); }
);

$command = util::subcommand() unless ( $command );
$command->run();
