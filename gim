#!/usr/bin/perl

use strict;
use warnings;
use utf8;
use open( ':std', ':encoding(UTF-8)' );

###################################################################
###################################################################
# Exit Codes
use constant E_OK            =>  0;
use constant E_SUB_MISSING   =>  1;  # No subcommand given
use constant E_SUB_UNKNOWN   =>  2;  # Subcommand unknown
use constant E_EXECUTE_FAIL  =>  3;  # Execution failure
use constant E_SIG_INTERRUPT =>  4;  # Interrupted by signal
use constant E_UNEXPECTED    =>  5;  # Unexpected backend error
###################################################################
# Colors

# Default is 'no color'
my $_COLOR   = 'never';
my $_RED     = '';
my $_GREEN   = '';
my $_BLUE    = '';
my $_YELLOW  = '';
my $_MAGENTA = '';
my $_CYAN    = '';
my $_RESET   = '';

if ( -t STDOUT )
{
    # If we are printing to terminal, *do* use colors.
    use Term::ANSIColor  qw( :constants );
    $_COLOR   = 'always';
    $_RED     = ::RED;
    $_GREEN   = ::GREEN;
    $_BLUE    = ::BLUE;
    $_YELLOW  = ::YELLOW;
    $_MAGENTA = ::MAGENTA;
    $_CYAN    = ::CYAN;
    $_RESET   = ::RESET;
}

# Color Scheme
my $_ERROR_COL    = $_RED;
my $_WARN_COL     = $_YELLOW;

###################################################################
###################################################################
# 'util' covers any utility subroutines.
package util
{
    # Check return code from external calls
    sub check_rc( $$ )
    {
        my ( $rc, $command ) = @_;

        # Mapping of signal numbers to signal names for error messages
        use Config '%Config';
        my @sig_names;
        @sig_names[ split( ' ', $Config{ sig_num } ) ] = split( ' ', $Config{ sig_name } );

        if ( $rc != 0 )
        {
            if ( $rc == -1 )
            {
                util::throw( ::E_EXECUTE_FAIL, util::text( 'Error: Failed to execute ‘[_1]’.', 'sh' ) );
            }
            elsif ( $rc & 127 )
            {
                $rc &= 127;
                util::throw( ::E_SIG_INTERRUPT, util::text( 'Error: ‘[_1]’ interrupted by signal [_2] ‘[_3]’.', $command, $rc, $sig_names[ $rc ] ) );
            }
            else
            {
                $rc = $rc >> 8;

                if ( $rc > 128 )
                {
                    $rc -= 128;
                    util::throw( ::E_SIG_INTERRUPT, util::text( 'Error: ‘[_1]’ interrupted by signal [_2] ‘[_3]’.', $command, $rc, $sig_names[ $rc ] ) );
                }
                if ( $rc == 127 )
                {
                    util::throw( ::E_EXECUTE_FAIL, util::text( 'Error: Failed to execute ‘[_1]’.', $command ) .
                                                   util::text( 'Command not found.' )
                    );
                }
                elsif ( $rc == 126 )
                {
                    util::throw( ::E_EXECUTE_FAIL, util::text( 'Error: Command ‘[_1]’ not executable.', $command ) );
                }
            }
        }

        return $rc;
    }

    # Execute external command.
    # rc => -1: Throw if command returns non-zero
    # rc =>  0: Throw on failure to execute
    # rc =>  1: Return the command's return code (default)
    # out => -1: Output pass through
    # out =>  0: Ignore the command's output (default)
    # out =>  1: Return the command's output
    sub execute( $;@ )
    {
        my $command = shift @_;
        my %options = ( rc => 1, out => 0, @_ );
        my $output = '';

        if ( $options{ out } >= 0 )
        {
            $output = `$command 2>&1`;
            chomp( $output );
        }
        else
        {
            system( "$command" );
        }

        my $rc = check_rc( $?, $command );

        if ( ( $options{ rc } == -1 ) && ( $rc != 0 ) )
        {
            util::throw( ::E_UNEXPECTED, util::text( 'Error: Failed to execute ‘[_1]’.', caller(0) ) .
                                         util::text( '‘[_1]’ returned ‘[_2]’:', $command, $rc ) .
                                         $output . "\n" );
        }

        if ( ( $options{ rc } == 1 ) && ( $options{ out } == 1 ) )
        {
            return ( $rc, $output );
        }
        elsif ( $options{ out } == 1 )
        {
            return $output;
        }
        else
        {
            return $rc;
        }
    }

    # Pull subcommand from @ARGV.
    # When called from the top level, checks existence of worker
    # class by that name, and returns an instance of that class.
    # When called from a worker class, checks existence of a run_*
    # subroutine of that name, and returns that subroutine name.
    sub subcommand()
    {
        my $subcommand = shift( @ARGV );
        my $caller = caller(0);
        my $help_hint;
        my $command;
        my $package;
        my $rc;

        if ( $caller eq 'gim' )
        {
            $help_hint = '';
            $command = $caller;
            $package = $subcommand;
        }
        else
        {
            $help_hint = ' ' . $caller;
            $command = 'gim ' . $caller;
            $package = $caller . '::' . $subcommand;
        }

        if ( ! defined( $subcommand ) )
        {
            util::throw( ::E_SUB_MISSING, util::text( 'Error: No subcommand given to ‘[_1]’.', $command ) );
        }

        if ( $package->isa( 'worker' ) && $package ne 'worker' )
        {
            $rc = $package->new();
        }
        else
        {
            util::throw( ::E_SUB_UNKNOWN, util::text( 'Error: Unknown subcommand ‘[_1]’.', $subcommand ) );
        }

        return $rc;
    }

    # Given a basic message and a list of arguments, this function:
    # 1) inserts arguments in place of placeholders '[_1]', '[_2]'
    #    etc. in the basic message;
    # 2) If input message started with "Error:" or "Warning:", will
    #    color output message up to the first ":" with _ERROR_COL /
    #    _WARN_COL.
    sub text( $;@ )
    {
        my $text = $_[0];

        # Replace '[_n]' with argument #n.
        for ( my $i = 1; $i < @_; ++$i )
        {
            $text =~ s/\[_$i\]/$_[ $i ]/;
        }

        if ( $_[0] =~ m/^Error:/ )
        {
            $text =~ s/^/$_ERROR_COL/;
            $text =~ s/:/:$_RESET/;
        }

        if ( $_[0] =~ m/^Warning:/ )
        {
            $text =~ s/^/$_WARN_COL/;
            $text =~ s/:/:$_RESET/;
        }

        return $text . "\n";
    }

    # Throw Gim two-element exception: $0 as the error code, $1 as
    # the exception message.
    sub throw( @ )
    {
        $! = $_[0];
        die( $_[1] . "\n" );
    }
}

###################################################################
###################################################################
# Similar to util::execute(), which provides combined stdout and
# stderr of a command in scalar return values, this class gives
# access to stdout of a command line by line.
#
# $self->{ out } is a stream handle on stdout.
# $self->{ err } is a stream handle on stderr.
# $self->{ errors } will receive a dump of $self->{ err } when
# $self->close() is called.
package executor
{
    # Requires the command to be executed as parameter.
    sub new( $ )
    {
        use IPC::Open3;
        my $class = shift( @_ );
        my $self = {};
        $self->{ command } = shift( @_ );
        bless( $self, $class );

        use Symbol 'gensym';
        $self->{ err } = gensym;
        eval { $self->{ pid } = open3( $self->{ in }, $self->{ out }, $self->{ err }, $self->{ command } ); };

        if ( $@ )
        {
            $self->{ pid } = 0;
            util::throw( ::E_EXECUTE_FAIL, util::text( 'Error: Failed to execute ‘[_1]’.', $self->{ command } ) . $! . "\n" );
        }

        $self->{ 'linecount' } = 0;

        return $self;
    }

    # Writes a line of output to $_.
    sub readline()
    {
        my $self = shift( @_ );
        my $fh = $self->{ out };

        if ( defined( $_ = <$fh> ) )
        {
            ++$self->{ 'linecount' };
        }

        return $_;
    }

    # Closes the stream, writing stderr to $self->{ errors }.
    # This is optional, as the destructor will do it anyway.
    sub close()
    {
        my $self = shift( @_ );

        if ( $self->{ pid } ne 0 )
        {
            my $fh = $self->{ err };
            $self->{ errors } = do { local $/; <$fh> };

            waitpid( $self->{ pid }, 0 );
            $self->{ pid } = 0;
            $self->{ rc } = util::check_rc( $?, $self->{ command } );
        }
    }

    sub DESTROY
    {
        my $self = shift;
        $self->close();
    }
}

###################################################################
###################################################################
# Base class for all subcommands.
package worker
{
    sub new()
    {
        my $class = shift( @_ );
        my $self = {};
        bless( $self, $class );
        return $self;
    }
}

###################################################################
# 'devel' covers everything for internal Gim development. None of
# this should ever be needed by the casual Gim user.
package devel
{
    our @ISA = 'worker';

    sub run()
    {
        my $self = shift( @_ );
        util::check_argv( 1, 1 );
        my $subcommand = util::subcommand();
        $subcommand->run();
        return ::E_OK;
    }

    # 'devel test' runs a list of regression tests.
    package devel::test
    {
        my $self = shift( @_ );
        my ( $rc, $output );

        # preparing test executable
        ( my $testexe = q{#!/usr/bin/env bash

        o=1
        e=1

        for arg in "$@"
        do
            case $arg in
                o)
                    echo "stdout$o"
                    o=$(($o + 1))
                    ;;
                e)
                    echo "stderr$e" >&2
                    e=$(($e + 1))
                    ;;
                [0-9])
                    exit $arg
                    ;;
                s)
                    kill -s SIGINT $$
                    ;;
            esac
        done
        }) =~ s/^ {8}//mg;
        open( my $fh, '>', 'testexe' ) || die( "Error: Could not open 'testexe' for writing.\n" . $! );
        print( $fh $testexe );
        close( $fh );
        chmod( 0755, 'testexe' );
        print( "Running self-tests:\n" );

        # util::execute()
        my $expected = "stdout1\nstdout2\nstdout3\nstderr1\nstdout4\nstdout5\nstdout6";
        eval { util::execute( 'nosuchcommand' ); }; die unless ( $@ =~ /.*Error:.* Failed to execute ‘nosuchcommand’\.\nCommand not found\./ );
        $rc = util::execute( './testexe o o o e o o o 0' ); die unless ( $rc == 0 );
        $rc = util::execute( './testexe o o o e o o o 1' ); die unless ( $rc == 1 );
        eval { util::execute( './testexe o o o e o o o s' ); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );
        $rc = util::execute( './testexe o o o e o o o 0', rc => 0 ); die unless ( $rc == 0 );
        $rc = util::execute( './testexe o o o e o o o 1', rc => 0 ); die unless ( $rc == 1 );
        eval { util::execute( './testexe o o o e o o o s', rc => 0 ); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );
        $rc = util::execute( './testexe o o o e o o o 0', rc => -1 ); die unless ( $rc == 0 );
        eval { util::execute( './testexe o o o e o o o 1', rc => -1 ); }; die unless ( $@ =~ /.*Error:.* Failed to execute ‘devel’\.\n.*‘\.\/testexe o o o e o o o 1’ returned ‘1’:\n$expected/ );
        eval { util::execute( './testexe o o o e o o o s', rc => -1 ); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );
        ( $rc, $output ) = util::execute( './testexe 0', out => 1 ); die unless ( ( $rc == 0 ) && ( $output eq '' ) );
        ( $rc, $output ) = util::execute( './testexe 1', out => 1 ); die unless ( ( $rc == 1 ) && ( $output eq '' ) );
        ( $rc, $output ) = util::execute( './testexe o o o e o o o 0', out => 1 ); die unless ( $rc == 0 && $output eq $expected );
        ( $rc, $output ) = util::execute( './testexe o o o e o o o 1', out => 1 ); die unless ( $rc == 1 && $output eq $expected );
        eval { util::execute( './testexe o o o e o o o s', out => 1 ); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );

        # executor
        my $exe;
        eval { $exe = new executor( 'nosuchcommand' ); }; die unless ( $@ =~ /.*Error:.* Failed to execute ‘nosuchcommand’\./ );
        $exe = new executor( './testexe o o o e o o o 0' );
        $rc = 1;
        while ( $exe->readline() )
        {
            chomp;
            die unless ( $_ eq "stdout$rc" );
            ++$rc;
        }
        $exe->close();
        die unless ( $exe->{ linecount } == 6 );
        die unless ( $exe->{ errors } eq "stderr1\n" );
        die unless ( $exe->{ rc } == 0 );
        $exe = new executor( './testexe o o o e o o o 1' ); $exe->close(); die unless ( $exe->{ rc } == 1 );
        $exe = new executor( './testexe o o o e o o o s' ); eval { $exe->close(); }; die unless ( $@ =~ /.*Error:.* ‘\.\/testexe o o o e o o o s’ interrupted by signal.*/ );

        # util::subcommand()
        ( util::execute( "$0" ) == ::E_SUB_MISSING ) || die;
        ( util::execute( "$0 foo" ) == ::E_SUB_UNKNOWN ) || die;
        ( util::execute( "$0 worker" ) == ::E_SUB_UNKNOWN ) || die;
        ( util::execute( "$0 devel" ) == ::E_SUB_MISSING ) || die;

        # Clean up
        unlink( 'testexe' );
        print( "Done.\n" );
    }
}

###################################################################
###################################################################
package gim;

print( $_RESET );

my $command = util::subcommand();
$command->run();
